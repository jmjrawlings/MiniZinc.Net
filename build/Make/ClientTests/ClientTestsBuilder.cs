namespace Make;

using LibMiniZinc.Tests;

public abstract class ClientTestsBuilder : TestBuilder
{
    protected ClientTestsBuilder(string className, TestSpec spec)
        : base(className, spec)
    {
        using (BlockComment())
        {
            WriteLn("<auto-generated>");
            WriteLn("This file has been auto generated by the following command:");
            WriteLn("dotnet run --project ./build/Make/Make.csproj --make-client-tests");
            Write("</auto-generated>");
        }

        WriteLn("#nullable enable");
        NewLine();
        Block($"public class {className} : ClientTest");
        NewLine();

        using (
            Block(
                $"public {className}(ITestOutputHelper output, ClientFixture fixture) : base(output, fixture)"
            )
        ) { }
    }

    protected void WriteMessage(object? msg = null)
    {
        if (msg is null)
            Call("_output.WriteLine", "\"\"");
        else
            Call("_output.WriteLine", msg.ToString()!);
    }

    protected void WriteSection() => WriteMessage("new string('-',80)");

    protected void WriteTest(TestCaseInfo info)
    {
        IDisposable block;
        if (info.Solvers.Count > 1)
        {
            Attribute("Theory", $"DisplayName=\"{info.Path}\"");
            foreach (var (solver, enabled) in info.Solvers)
            {
                if (enabled)
                    Attribute("InlineData", $"\"{solver}\"");
                else
                    Attribute($"InlineData", $"\"{solver}\", Skip=\"Solver not supported\"");
            }

            block = Function($"public async Task {info.Name}", "string solver");
            Var("path", $"\"{info.Path}\"");
        }
        else
        {
            var (solver, enabled) = info.Solvers[0];
            if (enabled)
                Attribute("Fact", $"DisplayName=\"{info.Path}\"");
            else
                Attribute("Fact", $"DisplayName=\"{info.Path}\"", "Skip=\"Solver not supported\"");

            block = Function($"public async Task {info.Name}");
            Var("path", $"\"{info.Path}\"");
            Var("solver", Quote(solver));
        }

        if (info.Solutions is not { Count: > 0 } solutions)
        {
            WriteLn("var solutions = new List<string>();");
        }
        else
        {
            WriteLn("var solutions = new List<string> {");
            using (Indent())
            {
                foreach (var sol in solutions)
                {
                    Write(TripleQuote(sol));
                    Append(',');
                    NewLine();
                }
                WriteLn("};");
            }
        }
        if (info.ExtraArgs is not { Count: > 0 } args)
        {
            WriteLn("var args = new List<string>();");
        }
        else
        {
            WriteLn("var args = new List<string>{");
            using (Indent())
            {
                foreach (var arg in args)
                {
                    Write(FormatArg(arg));
                    Append(',');
                    NewLine();
                }
            }
            WriteLn("};");
        }

        if (info.ErrorMessage is { } err)
            Declare("string", "error", $"\"{err}\"");
        else if (info.ErrorRegex is { } regex)
            Declare("string", "error", $"\"{regex.Replace("\\", "")}\"");
        else
            Declare("string?", "error", null);

        Var("allSolutions", info.Type is TestType.AllSolutions ? "true" : "false");

        WriteLn("var statuses = new List<SolveStatus>{");
        using (Indent())
        {
            switch (info.Type)
            {
                case TestType.Compile:
                    break;
                case TestType.Satisfy:
                    WriteLn("SolveStatus.Satisfied,SolveStatus.Optimal");
                    break;
                case TestType.AnySolution:
                    WriteLn("SolveStatus.Satisfied,SolveStatus.Optimal");
                    break;
                case TestType.AllSolutions:
                    WriteLn("SolveStatus.Satisfied,SolveStatus.Optimal");
                    break;
                case TestType.Optimise:
                    WriteLn("SolveStatus.Optimal");
                    break;
                case TestType.OutputModel:
                    break;
                case TestType.Unsatisfiable:
                    WriteLn("SolveStatus.Unsatisfiable");
                    break;
                case TestType.Error:
                    break;
                case TestType.AssertionError:
                    break;
                case TestType.EvaluationError:
                    break;
                case TestType.MiniZincError:
                    break;
                case TestType.TypeError:
                    break;
                case TestType.SyntaxError:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
        WriteLn("};");
        WriteLn("await Test(path, solver, solutions, args, error, allSolutions, statuses);");
        block.Dispose();
    }

    private string FormatDzn(string s)
    {
        var z = s.Replace("\n", "\\n");
        z = z.Replace("\"", "\\\"");
        z = $"\"{z}\"";
        return z;
    }

    private string FormatArg(string s)
    {
        // Some extra options are passed in as quoted strings
        if (s.StartsWith('"'))
            return s;

        var z = Quote(s);
        return z;
    }

    protected void WriteAllSolutionCheck()
    {
        Var("result", "await MiniZinc.Solve(model, options)");
        WriteMessage("result.Command");
        WriteLn("result.IsSuccess.Should().BeTrue();");
        using (ForEach("var dzn in solutions"))
        {
            Var("parsed", "Parser.ParseDataString(dzn, out var data);");
            WriteLn("parsed.Ok.Should().BeTrue();");
            using (If("!result.Data.Equals(data)"))
            {
                WriteMessage(Quote("EXPECTED:"));
                WriteMessage("data.Write()");
                WriteMessage();
                WriteMessage(Quote("ACTUAL"));
                WriteMessage("result.Data.Write()");
                WriteSection();
                Call("Assert.Fail", Quote("The result was not expected"));
            }
        }
    }

    protected void WriteAnySolutionCheck()
    {
        Var("result", "await MiniZinc.Solve(model, options)");
        WriteMessage("result.Command");
        WriteLn("result.IsSuccess.Should().BeTrue();");
        using (If("solutions.Count is 0"))
            Return();

        Var("anySolution", "false");
        using (ForEach("var expected in solutions"))
        {
            Var("parsed", "Parser.ParseDataString(dzn, out var data);");
            WriteLn("parsed.Ok.Should().BeTrue();");
            using (If("result.Data.Equals(data)"))
            {
                Assign("anySolution", "true");
                Break();
            }
            WriteMessage(Quote("EXPECTED:"));
            WriteMessage("data.Write()");
            WriteMessage();
            WriteMessage(Quote("ACTUAL:"));
            WriteMessage("result.Data.Write()");
            WriteSection();
        }
        WriteLn("anySolution.Should().BeTrue();");
    }
}
