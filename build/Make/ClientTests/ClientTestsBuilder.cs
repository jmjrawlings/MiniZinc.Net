using System.Text.Json;
using System.Text.Json.Nodes;
using LibMiniZinc.Tests;
using Make;
using MiniZinc.Build;

public abstract class ClientTestsBuilder : CodeBuilder
{
    public readonly TestSpec Spec;
    public readonly string ClassName;

    protected ClientTestsBuilder(string className, TestSpec spec)
    {
        ClassName = className;
        Spec = spec;
        using (BlockComment())
        {
            WriteLn("<auto-generated>");
            WriteLn("This file has been auto generated by the following command:");
            WriteLn("dotnet run --project ./build/Make/Make.csproj --make-client-tests");
            Write("</auto-generated>");
        }

        WriteLn("#nullable enable");
        NewLine();
        Block($"public class {className} : IClassFixture<ClientFixture>");
        WriteLn("private readonly MiniZincClient MiniZinc;");
        WriteLn("private readonly ITestOutputHelper _output;");
        NewLine();

        using (Function($"public {className}", "ClientFixture fixture", "ITestOutputHelper output"))
        {
            Assign("MiniZinc", "fixture.MiniZinc");
            Assign("_output", "output");
        }
    }

    protected void WriteMessage(object? msg)
    {
        Call("_output.WriteLine", $"{msg?.ToString() ?? string.Empty}");
    }

    protected void WriteSection() => WriteMessage("new string('-',80)");

    protected IDisposable WriteTestHeader(TestCaseInfo info)
    {
        IDisposable block;
        if (info.Solvers.Count > 1)
        {
            Attribute("Theory", $"DisplayName=\"{info.Path}\"");
            foreach (var (solver, enabled) in info.Solvers)
            {
                if (enabled)
                    Attribute("InlineData", $"\"{solver}\"");
                else
                    Attribute($"InlineData", $"\"{solver}\", Skip=\"Solver not supported\"");
            }

            block = Function($"public async Task {info.Name}", "string solver");
            Var("path", $"\"{info.Path}\"");
        }
        else
        {
            var (solver, enabled) = info.Solvers[0];
            if (enabled)
                Attribute("Fact", $"DisplayName=\"{info.Path}\"");
            else
                Attribute("Fact", $"DisplayName=\"{info.Path}\"", "Skip=\"Solver not supported\"");

            block = Function($"public async Task {info.Name}");
            Var("path", $"\"{info.Path}\"");
            Var("solver", Quote(solver));
        }

        if (info.Solutions is not { Count: > 0 } solutions)
        {
            WriteLn("List<(string,bool)>? solutions = null;");
            return block;
        }

        WriteLn("var solutions = new List<(string, bool)> {");

        using (Indent())
        {
            foreach (var sol in solutions)
            {
                if (sol.Dzn is { } dzn)
                {
                    Write('(');
                    Append(FormatDzn(dzn));
                    Append(',');
                    Append("false");
                    Append(')');
                    Append(',');
                    NewLine();
                }
                else if (sol.Ozn is { } ozn)
                {
                    Write('(');
                    Append(FormatDzn(ozn));
                    Append(',');
                    Append("true");
                    Append(')');
                    Append(',');
                    NewLine();
                }
            }
        }
        WriteLn("};");
        NewLine();
        return block;
    }

    private string FormatDzn(string s)
    {
        var z = s.Replace("\n", "\\n");
        z = z.Replace("\"", "\\\"");
        z = $"\"{z}\"";
        return z;
    }

    protected TestCaseInfo? GetTestInfo(TestCase testCase)
    {
        var testName = testCase.Path.Replace(".mzn", "");
        testName = testName.Replace("/", "_");
        testName = testName.Replace("-", "_");
        testName = testName.Replace(".", "_");
        testName = $"test_solve_{testName}";
        if (testCase.Sequence > 1)
            testName = $"{testName}_{testCase.Sequence}";

        var testPath = testCase.Path;
        var testDir = Path.GetDirectoryName(testPath)!;
        var info = new TestCaseInfo
        {
            Path = testPath,
            Dir = testDir,
            Name = testName,
            Signature = $"async Task {testName}(string solver)",
            Options = testCase.Options,
            Sequence = testCase.Sequence,
            Solutions = testCase.Solutions,
            InputFiles = testCase.InputFiles,
            ErrorMessage = testCase.ErrorMessage,
            ErrorRegex = testCase.ErrorRegex,
            CheckAgainstSolvers = testCase.CheckAgainstSolvers,
            Type = testCase.Type,
            OutputFiles = testCase.OutputFiles
        };

        if (testCase.Solvers is null)
            return null;

        if (testCase.Options is JsonObject opts)
        {
            foreach (var kv in opts)
            {
                var key = kv.Key;
                var val = kv.Value;
                var kind = val.GetValueKind();
                if (!key.StartsWith('-'))
                    key = $"--{key}";

                string arg;
                if (kind is JsonValueKind.True)
                {
                    arg = key;
                }
                else
                {
                    var value = val.ToString();
                    if (value.Contains(' '))
                        arg = $"{key} \\\"{value}\\\"";
                    else
                        arg = $"{key} {value}";
                }
                info.ExtraArgs.Add(arg);
            }
        }

        if (testCase.InputFiles is { } extraFiles)
        {
            foreach (var extraFile in extraFiles)
            {
                var extraPath = Path.Combine(testDir!, extraFile);
                extraPath = extraPath.Replace('\\', '/');
                info.ExtraArgs.Add($"--data \\\"{extraPath}\\\"");
            }
        }

        foreach (var solver in testCase.Solvers)
        {
            info.Solvers.Add(
                solver switch
                {
                    "cbc" => ("coin-bc", true),
                    "scip" => ("scip", false),
                    "gurobi" => ("gurobi", false),
                    _ => (solver, true)
                }
            );
        }

        if (testCase.Solutions is not null)
        {
            foreach (var sol in testCase.Solutions)
            {
                if (string.IsNullOrEmpty(sol.Dzn))
                    sol.Dzn = null;
                else
                    sol.Dzn = sol.Dzn;

                if (string.IsNullOrEmpty(sol.Ozn))
                    sol.Ozn = null;
                else
                    sol.Ozn = sol.Ozn;
            }
        }
        return info;
    }

    public void WriteTo(DirectoryInfo directory)
    {
        var file = directory.JoinFile($"{ClassName}.cs");
        var source = ToString();
        File.WriteAllText(file.FullName, source);
    }

    protected void AppendArgs(List<string> args)
    {
        foreach (var arg in args)
        {
            Append(',');
            Append(Quote(arg));
        }
    }
}
