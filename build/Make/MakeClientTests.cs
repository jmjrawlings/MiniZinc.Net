namespace Make;

using System.Text.Json;
using System.Text.Json.Nodes;
using LibMiniZinc.Tests;
using MiniZinc.Build;

public sealed class MakeClientTests : CodeBuilder
{
    private MakeClientTests(TestSpec spec)
    {
        WriteLn(
            @"
/* 
THIS FILE WAS GENERATED BY THE FOLLOWING COMMAND

dotnet run --project ./build/Make/Make.csproj --make-client-tests
*/"
        );

        Block("public class ClientIntegrationTests : IClassFixture<ClientFixture>");
        WriteLn("const int DEFAULT_TIMEOUT_MS = 10000;");
        WriteLn("static TimeSpan DefaultTimeout = TimeSpan.FromMilliseconds(DEFAULT_TIMEOUT_MS);");
        WriteLn("private readonly MiniZincClient MiniZinc;");
        WriteLn("private readonly ITestOutputHelper _output;");

        using (
            Block("public ClientIntegrationTests(ClientFixture fixture, ITestOutputHelper output)")
        )
        {
            WriteLn("MiniZinc = fixture.Client;");
            WriteLn("_output = output;");
        }
        var files = spec.TestCases.GroupBy(c => c.Path);
        foreach (var group in files)
        {
            int i = 1;
            var g = group.ToList();
            foreach (var testCase in group)
            {
                testCase.Sequence = i++;
                MakeTest(testCase);
            }
        }
    }

    /// <summary>
    /// Generate an xunit test from the given TestSpec test case
    /// </summary>
    void MakeTest(TestCase testCase)
    {
        var testName = testCase.Path.Replace(".mzn", "");
        testName = testName.Replace("/", "_");
        testName = testName.Replace("-", "_");
        testName = $"test_solve_{testName}";
        if (testCase.Sequence > 1)
            testName = $"{testName}_case_{testCase.Sequence}";

        var path = testCase.Path;
        if (testCase.Solvers is not { } solvers)
            return;

        var solverIds = new List<string>();
        foreach (var solver in solvers)
        {
            var solverId = solver switch
            {
                "cbc" => "coin-bc",
                "gurobi" => null,
                _ => solver
            };

            if (solverId is not null)
                solverIds.Add(solverId);
        }

        if (solverIds.Count == 0)
            return;

        List<string> extraArgs = new List<string>();
        if (testCase.Options is JsonObject opts)
        {
            foreach (var kv in opts)
            {
                var key = kv.Key;
                var val = kv.Value;
                var kind = val.GetValueKind();
                if (!key.StartsWith('-'))
                    key = $"--{key}";

                if (kind is JsonValueKind.True)
                    extraArgs.Add($"{key}");
                else
                    extraArgs.Add($"{key} {val}");
            }
        }

        IDisposable block;
        if (solverIds.Count > 1)
        {
            Attribute($"Theory(DisplayName=\"{path}\")");
            foreach (var solver in solverIds)
                Attribute($"InlineData(\"{solver}\")");
            block = Block($"public async void {testName}(string solver)");
        }
        else
        {
            Attribute($"Fact(DisplayName=\"{path}\")");
            block = Block($"public async void {testName}()");
            Var("solver", $"\"{solverIds[0]}\"");
        }

        Var("path", $"\"{path}\"");
        Var("model", "Model.FromFile(path)");
        WriteLn("_output.WriteLine(model.SourceText);");
        Var("options", "SolveOptions.Create(solverId:solver)");
        WriteLn("options = options.WithTimeout(DefaultTimeout);");
        foreach (var arg in extraArgs)
            WriteLn($"options = options.AddArgs(\"{arg}\");");

        switch (testCase.Type)
        {
            case TestType.Compile:
                MakeCompileTest(testName, testCase);
                break;
            case TestType.Satisfy:
                MakeSatisfyTest(testName, testCase);
                break;
            case TestType.Optimise:
                MakeOptimiseTest(testName, testCase);
                break;
            case TestType.AnySolution:
                MakeAnySolutionTest(testName, testCase);
                break;
            case TestType.AllSolutions:
                MakeAllSolutionsTest(testName, testCase);
                break;
            case TestType.OutputModel:
                MakeOutputTest(testName, testCase);
                break;
            case TestType.Unsatisfiable:
                MakeUnsatisfiableTest(testName, testCase);
                break;
            case TestType.Error:
                MakeErrorTest(testName, testCase);
                break;
        }
        block.Dispose();
        Newline();
    }

    private void MakeUnsatisfiableTest(string testName, TestCase testCase)
    {
        Var("solution", "await MiniZinc.Solve(model, options)");
        WriteLn("solution.Status.Should().Be(SolveStatus.Unsatisfiable);");
    }

    private void MakeAllSolutionsTest(string testName, TestCase testCase)
    {
        Var("solution", "await MiniZinc.Solve(model, options)");
        WriteLn("solution.Status.Should().Be(SolveStatus.Satisfied);");
    }

    private void MakeAnySolutionTest(string testName, TestCase testCase)
    {
        Var("solution", "await MiniZinc.Solve(model, options)");
        WriteLn("solution.Status.Should().Be(SolveStatus.Satisfied);");
    }

    private void MakeSatisfyTest(string testName, TestCase testCase)
    {
        Var("solution", "await MiniZinc.Solve(model,options)");
        WriteLn("solution.Status.Should().Be(SolveStatus.Satisfied);");
    }

    private void MakeOptimiseTest(string testName, TestCase testCase)
    {
        Var("solution", "await MiniZinc.Solve(model,options)");
        WriteLn("solution.Status.Should().Be(SolveStatus.Optimal);");
    }

    private void MakeCompileTest(string testName, TestCase testCase) { }

    private void MakeErrorTest(string testName, TestCase testCase) { }

    private void MakeOutputTest(string testName, TestCase testCase) { }

    public static async Task Run()
    {
        var spec = TestSpec.FromJsonFile(Repo.TestSpecJson);
        var generator = new MakeClientTests(spec);
        var source = generator.ToString();
        var file = Projects.ClientTests.Dir.JoinFile("ClientIntegrationTests.cs");
        await File.WriteAllTextAsync(file.FullName, source);
    }
}
