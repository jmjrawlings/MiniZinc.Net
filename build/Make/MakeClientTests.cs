namespace Make;

using System.Text.Json;
using System.Text.Json.Nodes;
using LibMiniZinc.Tests;
using MiniZinc.Build;

public sealed class MakeClientTests : CodeBuilder
{
    private MakeClientTests(TestSpec spec)
    {
        WriteLn(
            @"
/* 
THIS FILE WAS GENERATED BY THE FOLLOWING COMMAND

dotnet run --project ./build/Make/Make.csproj --make-client-tests
*/"
        );

        Block("public class ClientIntegrationTests : IClassFixture<ClientFixture>");
        WriteLn("static TimeSpan DefaultTimeout = TimeSpan.FromMinutes(5);");
        WriteLn("private readonly MiniZincClient MiniZinc;");
        WriteLn("private readonly ITestOutputHelper _output;");

        using (
            Function(
                "public ClientIntegrationTests",
                "ClientFixture fixture",
                "ITestOutputHelper output"
            )
        )
        {
            WriteLn("MiniZinc = fixture.Client;");
            WriteLn("_output = output;");
        }

        using (Function("private void Write", "string msg"))
            WriteLn("_output.WriteLine(msg);");

        using (Function("private void WriteWarning", "string msg"))
            WriteLn("Write($\"WARNING - {msg}\");");

        using (Function("private void WriteError", "string msg"))
            WriteLn("Write($\"ERROR - {msg}\");");

        using (Function("private void WriteSection"))
            WriteLn("Write(new string('-',80));");

        var files = spec.TestCases.GroupBy(c => c.Path);
        foreach (var group in files)
        {
            int i = 1;
            var g = group.ToList();
            foreach (var testCase in group)
            {
                testCase.Sequence = i++;
                MakeTest(testCase);
            }
        }
    }

    /// <summary>
    /// Generate an xunit test from the given TestSpec test case
    /// </summary>
    void MakeTest(TestCase testCase)
    {
        var testName = testCase.Path.Replace(".mzn", "");
        testName = testName.Replace("/", "_");
        testName = testName.Replace("-", "_");
        testName = $"test_solve_{testName}";
        if (testCase.Sequence > 1)
            testName = $"{testName}_case_{testCase.Sequence}";

        var path = testCase.Path;
        if (testCase.Solvers is not { } solvers)
            return;

        var solverIds = new List<string>();
        foreach (var solver in solvers)
        {
            var solverId = solver switch
            {
                "cbc" => "coin-bc",
                "gurobi" => null,
                _ => solver
            };

            if (solverId is not null)
                solverIds.Add(solverId);
        }

        if (solverIds.Count == 0)
            return;

        List<string> extraArgs = new List<string>();
        if (testCase.Options is JsonObject opts)
        {
            foreach (var kv in opts)
            {
                var key = kv.Key;
                var val = kv.Value;
                var kind = val.GetValueKind();
                if (!key.StartsWith('-'))
                    key = $"--{key}";

                string arg;
                if (kind is JsonValueKind.True)
                {
                    arg = key;
                }
                else
                {
                    var value = val.ToString();
                    if (value.Contains(' '))
                        arg = $"{key} \\\"{value}\\\"";
                    else
                        arg = $"{key} {value}";
                }
                extraArgs.Add(arg);
            }
        }

        IDisposable block;
        if (solverIds.Count > 1)
        {
            Attribute($"Theory(DisplayName=\"{path}\")");
            foreach (var solver in solverIds)
                Attribute($"InlineData(\"{solver}\")");
            block = Block($"public async Task {testName}(string solver)");
        }
        else
        {
            Attribute($"Fact(DisplayName=\"{path}\")");
            block = Block($"public async Task {testName}()");
            Var("solver", $"\"{solverIds[0]}\"");
        }

        Var("path", $"\"{path}\"");
        Call("Write", "$\"Solving {path} with {solver}\"");
        Var("model", "Model.FromFile(path)");
        Call("WriteSection");
        Call("Write", "model.SourceText");
        using (ForEach("var warn in model.Warnings"))
            Call("WriteWarning", "warn");

        using (ForEach("var err in model.Errors"))
            Call("WriteError", "err");

        Call("WriteSection");
        Var("options", "SolveOptions.Create(solverId:solver)");
        WriteLn("options = options.WithTimeout(DefaultTimeout);");
        foreach (var arg in extraArgs)
            WriteLn($"options = options.AddArgs(\"{arg}\");");

        switch (testCase.Type)
        {
            case TestType.Compile:
                MakeCompileTest(testName, testCase);
                break;
            case TestType.Satisfy:
                MakeSatisfyTest(testName, testCase);
                break;
            case TestType.Optimise:
                MakeOptimiseTest(testName, testCase);
                break;
            case TestType.AnySolution:
                MakeAnySolutionTest(testName, testCase);
                break;
            case TestType.AllSolutions:
                MakeAllSolutionsTest(testName, testCase);
                break;
            case TestType.Error:
                MakeErrorTest(testName, testCase);
                break;
            case TestType.OutputModel:
                MakeOutputTest(testName, testCase);
                break;
            case TestType.Unsatisfiable:
                MakeUnsatisfiableTest(testName, testCase);
                break;
        }

        block.Dispose();
        Newline();
    }

    private void MakeErrorTest(string testName, TestCase testCase)
    {
        using (Block("if (model.HasErrors)"))
            WriteLn("return;");
        Var("solution", "await MiniZinc.Solve(model, options)");
        WriteLn("solution.Status.Should().Be(SolveStatus.Error);");
    }

    private void MakeUnsatisfiableTest(string testName, TestCase testCase)
    {
        Var("solution", "await MiniZinc.Solve(model, options)");
        WriteLn("solution.Status.Should().Be(SolveStatus.Unsatisfiable);");
    }

    private void MakeAllSolutionsTest(string testName, TestCase testCase)
    {
        Var("solution", "await MiniZinc.Solve(model, options)");
        WriteLn("solution.Status.Should().Be(SolveStatus.Satisfied);");
    }

    private void MakeAnySolutionTest(string testName, TestCase testCase)
    {
        Var("solution", "await MiniZinc.Solve(model, options)");
        WriteLn("solution.Status.Should().BeOneOf(SolveStatus.Satisfied, SolveStatus.Optimal);");
    }

    private void MakeSatisfyTest(string testName, TestCase testCase)
    {
        Var("solution", "await MiniZinc.Solve(model,options)");
        WriteLn("solution.Status.Should().Be(SolveStatus.Satisfied);");
    }

    private void MakeOptimiseTest(string testName, TestCase testCase)
    {
        Var("solution", "await MiniZinc.Solve(model,options)");
        WriteLn("solution.Status.Should().Be(SolveStatus.Optimal);");
    }

    private void MakeCompileTest(string testName, TestCase testCase)
    {
        var a = 1;
    }

    private void MakeOutputTest(string testName, TestCase testCase) { }

    public static async Task Run()
    {
        var spec = TestSpec.FromJsonFile(Repo.TestSpecJson);
        var generator = new MakeClientTests(spec);
        var source = generator.ToString();
        var file = Projects.ClientTests.Dir.JoinFile("ClientIntegrationTests.cs");
        await File.WriteAllTextAsync(file.FullName, source);
    }
}
