namespace Make;

using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using LibMiniZinc.Tests;
using MiniZinc.Build;

public sealed class MakeClientTests : CodeBuilder
{
    private MakeClientTests(TestSpec spec)
    {
        WriteLn(
            """
            /*
            THIS FILE WAS GENERATED BY THE FOLLOWING COMMAND

            dotnet run --project ./build/Make/Make.csproj --make-client-tests
            */
            """
        );

        Block("public class ClientIntegrationTests : IClassFixture<ClientFixture>");
        WriteLn("private readonly MiniZincClient MiniZinc;");
        WriteLn("private readonly ITestOutputHelper _output;");

        using (
            Function(
                "public ClientIntegrationTests",
                "ClientFixture fixture",
                "ITestOutputHelper output"
            )
        )
        {
            WriteLn("MiniZinc = fixture.Client;");
            WriteLn("_output = output;");
        }

        using (Function("private void Write", "object? msg"))
            WriteLn("_output.WriteLine(msg?.ToString() ?? string.Empty);");

        using (Function("private void WriteWarning", "string msg"))
            WriteLn("Write($\"WARNING - {msg}\");");

        using (Function("private void WriteError", "string msg"))
            WriteLn("Write($\"ERROR - {msg}\");");

        using (Function("private void WriteSection"))
            WriteLn("Write(new string('-',80));");

        using (Function("Model Compile", "string path"))
        {
            Write(
                """
                Write(path);
                WriteSection();
                var model = Model.FromFile(path);
                Write(model.SourceText);
                WriteSection();
                foreach (var warn in model.Warnings)
                    WriteWarning(warn);
                return model;
                """
            );
        }

        using (
            Function(
                "async Task<SolveResult> Solve",
                "Model model",
                "SolveOptions options",
                "params SolveStatus[] statuses"
            )
        )
        {
            Write(
                """
                var solution = await MiniZinc.Solve(model, options);
                Write(options.SolverId);
                Write(solution.Command);
                Write(solution.Status);
                WriteSection();
                var ok = statuses.Length == 0;
                foreach (var status in statuses){
                    if (solution.Status == status){
                        ok = true;
                        break;
                    }
                }
                ok.Should().BeTrue($"{solution.Status} - {solution.Error}");
                return solution;
                """
            );
        }

        var files = spec.TestCases.GroupBy(c => c.Path);
        foreach (var group in files)
        {
            int i = 1;
            var g = group.ToList();
            foreach (var testCase in group)
            {
                testCase.Sequence = i++;
                MakeTest(testCase);
            }
        }
    }

    /// <summary>
    /// Generate an xunit test from the given TestSpec test case
    /// </summary>
    void MakeTest(TestCase testCase)
    {
        var testName = testCase.Path.Replace(".mzn", "");
        testName = testName.Replace("/", "_");
        testName = testName.Replace("-", "_");
        testName = $"test_solve_{testName}";
        if (testCase.Sequence > 1)
            testName = $"{testName}_case_{testCase.Sequence}";

        var path = testCase.Path;
        var dir = Path.GetDirectoryName(path);
        if (testCase.Solvers is null)
            return;

        var solvers = new List<(string, bool)>();
        foreach (var solver in testCase.Solvers)
        {
            solvers.Add(
                solver switch
                {
                    "cbc" => ("coin-bc", true),
                    "scip" => ("scip", false),
                    "gurobi" => ("gurobi", false),
                    _ => (solver, true)
                }
            );
        }

        List<string> extraArgs = new List<string>();
        if (testCase.Options is JsonObject opts)
        {
            foreach (var kv in opts)
            {
                var key = kv.Key;
                var val = kv.Value;
                var kind = val.GetValueKind();
                if (!key.StartsWith('-'))
                    key = $"--{key}";

                string arg;
                if (kind is JsonValueKind.True)
                {
                    arg = key;
                }
                else
                {
                    var value = val.ToString();
                    if (value.Contains(' '))
                        arg = $"{key} \\\"{value}\\\"";
                    else
                        arg = $"{key} {value}";
                }
                extraArgs.Add(arg);
            }
        }

        if (testCase.CheckAgainstSolvers is not null)
            // TODO
            return;

        if (testCase.InputFiles is { } extraFiles)
        {
            foreach (var extraFile in extraFiles)
            {
                var extraPath = Path.Combine(dir!, extraFile);
                extraPath = extraPath.Replace('\\', '/');
                extraArgs.Add($"--data \\\"{extraPath}\\\"");
            }
        }

        IDisposable block;
        if (solvers.Count > 1)
        {
            Attribute($"Theory(DisplayName=\"{path}\")");
            foreach (var (solver, enabled) in solvers)
            {
                if (enabled)
                    Attribute($"InlineData(\"{solver}\")");
                else
                    Attribute($"InlineData(\"{solver}\", Skip=\"Solver not supported\")");
            }
            block = Block($"public async Task {testName}(string solver)");
        }
        else
        {
            var (solver, enabled) = solvers[0];
            if (enabled)
                Attribute($"Fact(DisplayName=\"{path}\")");
            else
                Attribute($"Fact(DisplayName=\"{path}\", Skip=\"Solver not supported\")");
            block = Block($"public async Task {testName}()");
            Var("solver", $"\"{solver}\"");
        }
        Var("path", $"\"{path}\"");
        Var("model", "Compile(path)");
        Var("options", "SolveOptions.Create(solverId:solver)");
        foreach (var arg in extraArgs)
            WriteLn($"options = options.AddArgs(\"{arg}\");");

        switch (testCase.Type)
        {
            case TestType.Compile:
                MakeCompileTest(testName, testCase);
                break;
            case TestType.Satisfy:
                MakeSatisfyTest(testName, testCase);
                break;
            case TestType.Optimise:
                MakeOptimiseTest(testName, testCase);
                break;
            case TestType.AnySolution:
                MakeAnySolutionTest(testName, testCase);
                break;
            case TestType.AllSolutions:
                MakeAllSolutionsTest(testName, testCase);
                break;
            case TestType.Error:
            case TestType.AssertionError:
            case TestType.EvaluationError:
            case TestType.MiniZincError:
            case TestType.TypeError:
            case TestType.SyntaxError:
                MakeErrorTest(testName, testCase);
                break;
            case TestType.OutputModel:
                MakeOutputTest(testName, testCase);
                break;
            case TestType.Unsatisfiable:
                MakeUnsatisfiableTest(testName, testCase);
                break;
        }

        block.Dispose();
        Newline();
    }

    private void MakeErrorTest(string testName, TestCase testCase)
    {
        if (testCase.Type is TestType.SyntaxError)
        {
            WriteLn("model.HasErrors.Should().BeTrue();");
            return;
        }

        Var("solution", "await Solve(model, options)");
        WriteLn("solution.IsError.Should().BeTrue();");
        if (testCase.ErrorRegex is { } regex)
        {
            regex = regex.Replace("\\", "");
            WriteLn($"solution.Error.Should().MatchRegex(\"{regex}\");");
        }
        else if (testCase.ErrorMessage is { } error)
            WriteLn($"solution.Error.Should().Be(\"{error}\");");
    }

    private void MakeUnsatisfiableTest(string testName, TestCase testCase)
    {
        Var("solution", "await Solve(model, options, SolveStatus.Unsatisfiable)");
    }

    private void MakeAllSolutionsTest(string testName, TestCase testCase)
    {
        Var("solution", "await Solve(model, options, SolveStatus.Satisfied)");
    }

    private void MakeAnySolutionTest(string testName, TestCase testCase)
    {
        Var("solution", "await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal)");
    }

    private void MakeSatisfyTest(string testName, TestCase testCase)
    {
        Var("solution", "await Solve(model,options, SolveStatus.Satisfied)");
    }

    private void MakeOptimiseTest(string testName, TestCase testCase)
    {
        Var("solution", "await Solve(model,options,SolveStatus.Optimal)");
    }

    private void MakeCompileTest(string testName, TestCase testCase)
    {
        var a = 1;
    }

    private void MakeOutputTest(string testName, TestCase testCase) { }

    public static async Task Run()
    {
        var spec = TestSpec.FromJsonFile(Repo.TestSpecJson);
        var generator = new MakeClientTests(spec);
        var source = generator.ToString();
        var file = Projects.ClientTests.Dir.JoinFile("ClientIntegrationTests.cs");
        await File.WriteAllTextAsync(file.FullName, source);
    }
}
