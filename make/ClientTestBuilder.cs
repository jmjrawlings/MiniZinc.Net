namespace Make;

using System.Collections.Immutable;
using System.Reflection.Metadata;
using System.Text;
using MiniZinc.Build;
using MiniZinc.Tests;
using static CodeBuilder;

public static class ClientTestsBuilder
{
    public static void BuildSolveTests(TestSpec spec, DirectoryInfo dir)
    {
        var cb = new CodeBuilder();
        var className = $"SolveIntegrationTests";
        var file = dir.JoinFile($"{className}.cs");

        using (cb.BlockComment())
        {
            cb.WriteLn("<auto-generated>");
            cb.WriteLn("This file has been auto generated by the following command:");
            cb.WriteLn("dotnet run --project ./build/Make/Make.csproj --make-client-tests");
            cb.Write("</auto-generated>");
        }

        cb.WriteLn("#nullable enable");
        cb.WriteLn("namespace MiniZinc.Tests;");
        cb.NewLine();
        cb.Attribute("NotInParallel");
        cb.Block($"public class {className} : IntegrationTests");
        cb.NewLine();

        var cases = spec
            .TestCases.Where(tc => tc.Type == TestType.SOLVE)
            .GroupBy(tc => tc.Path)
            .ToArray();

        foreach (var kv in cases)
        {
            var path = kv.Key;
            var testCases = kv.ToArray();
            var qpath = Quote(path);
            int i = 0;

            foreach (TestCase testCase in testCases)
            {
                string qargs = Quote(testCase.Args);
                string qsolution = testCase.Solutions switch
                {
                    { Count: 1 } => QuoteSolution(testCase.Solutions[0]),
                    null => "null",
                    _ => throw new Exception()
                };

                if (testCase.Solvers is not { Count: > 0 } solvers)
                    solvers = ["gecode"];

                if (testCase.ExtraFiles is not { Count: > 0 } extras)
                    extras = [null];

                var testName = GetTestName(path);

                foreach (var tsolver in solvers)
                {
                    var (solver, enabled) = GetSolverInfo(tsolver);
                    var qsolver = Quote(solver);
                    foreach (string? extra in extras)
                    {
                        var qextra = Quote(extra);
                        cb.Attribute("Test");
                        cb.Attribute(
                            "DisplayName",
                            Quote($"{path} {solver} {qargs.Replace("\"", "")}")
                        );
                        using var _ = cb.Function($"public async Task {testName}_{++i}");
                        cb.Declare("string", "solver", qsolver);
                        cb.Declare("string?", "args", qargs);
                        cb.Declare("string?", "solution", qsolution);
                        cb.WriteLn($"await RunSolveTest({qpath},solver,args,solution);");
                    }
                }
            }
        }
        var source = cb.ToString();
        File.WriteAllText(file.FullName, source);
    }

    private static string QuoteSolution(string? solution)
    {
        if (solution is null)
            return "null";
        return TripleQuote(solution);
    }

    private static string QuoteSolutions(List<string> solutions)
    {
        List<string> array = [];
        foreach (var sol in solutions ?? [])
            array.Add(QuoteSolution(sol));

        string solutionsCs = $"[{string.Join(", ", array)}]";
        return solutionsCs;
    }

    private static string GetTestName(string path)
    {
        var name = path.Replace(".mzn", "");
        name = name.Replace("/", "_");
        name = name.Replace("-", "_");
        name = name.Replace(".", "");
        name = $"test_{name}";
        return name;
    }

    static string FormatDzn(string s)
    {
        var z = s.Replace("\n", "\\n");
        z = z.Replace("\"", "\\\"");
        z = $"\"{z}\"";
        return z;
    }

    static string FormatArg(string s)
    {
        // Some extra options are passed in as quoted strings
        if (s.StartsWith('"'))
            return s;

        var z = CodeBuilder.Quote(s);
        return z;
    }

    static void WriteMessage(this CodeBuilder cb, object? msg = null)
    {
        if (msg is null)
            cb.Call("_output.WriteLine", "\"\"");
        else
            cb.Call("_output.WriteLine", msg.ToString()!);
    }

    static void WriteSection(this CodeBuilder cb) => cb.WriteMessage("new string('-',80)");

    // static string GetTypeName(TestType type) =>
    //     type switch
    //     {
    //         TestType.SOLVE => "Solve",
    //         TestType.COMPILE => "Compile",
    //         TestType.OUTPUT_MODEL => "OutputModel",
    //         TestType.CHECK_AGAINST => "CheckAgainst",
    //         TestType.ALL_SOLUTIONS => "AllSolutions",
    //         TestType.UNSATISFIABLE => "Unsatisfiable",
    //         TestType.ERROR => "Error",
    //         TestType.ASSERTION_ERROR => "AssertionError",
    //         TestType.EVALUATION_ERROR => "EvaluationError",
    //         TestType.MINIZINC_ERROR => "MiniZincError",
    //         TestType.TYPE_ERROR => "TypeError",
    //         TestType.SYNTAX_ERROR => "SyntaxError",
    //         TestType.OUTPUT => "Output"
    //     };

    private static (string id, bool enabled) GetSolverInfo(string solver) =>
        solver switch
        {
            "cbc" => ("coin-bc", true),
            "scip" => ("scip", false),
            "gurobi" => ("gurobi", false),
            "gecode_presolver" => ("gecode_presolver", false),
            _ => ("gecode", true)
        };
}
