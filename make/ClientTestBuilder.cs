namespace Make;

using System.Collections.Immutable;
using System.Reflection.Metadata;
using System.Text;
using MiniZinc.Build;
using MiniZinc.Tests;
using static CodeBuilder;

public static class ClientTestsBuilder
{
    public static string Build(TestCase[] tests, string className)
    {
        var cb = new CodeBuilder();

        using (cb.BlockComment())
        {
            cb.WriteLn("<auto-generated>");
            cb.WriteLn("This file has been auto generated by the following command:");
            cb.WriteLn("dotnet run --project ./build/Make/Make.csproj --make-client-tests");
            cb.Write("</auto-generated>");
        }

        cb.WriteLn("#nullable enable");
        cb.WriteLn("namespace MiniZinc.Tests;");
        cb.NewLine();
        cb.Attribute("NotInParallel");
        cb.Attribute("Timeout", "10_000");
        cb.Block($"public class {className} : IntegrationTests");
        cb.NewLine();

        foreach (var testCase in tests)
        {
            var testType = testCase.Type;
            var testPath = testCase.Path;
            var testSolutions = testCase.Solutions;
            var quotedPath = Quote(testPath);
            string quotedArgs = Quote(testCase.Args);
            string quotedSolutions = "null";
            switch (testType, testSolutions)
            {
                case (TestType.SOLVE, [var solveSolution]):
                    quotedSolutions = QuoteSolution(solveSolution);
                    break;

                case (TestType.ANY_SOLUTION, { Count: > 0 } anySolutions):
                    quotedSolutions =
                        '[' + string.Join(',', anySolutions.Select(QuoteSolution)) + ']';
                    break;
            }

            if (testCase.Solvers is not { Count: > 0 } solvers)
                solvers = ["gecode"];

            if (testCase.ExtraFiles is not { Count: > 0 } extraFiles)
                extraFiles = [null];

            foreach (string testSolver in solvers)
            {
                var (solverId, solverEnabled) = GetSolverInfo(testSolver);
                if (!solverEnabled)
                    continue;

                var quotedSolver = Quote(solverId);
                foreach (string? extraFile in extraFiles)
                {
                    string quotedExtraFile = Quote(extraFile);
                    var testName = GetTestName(testPath, testSolver);
                    cb.Attribute("Test");
                    cb.Attribute("DisplayName", Quote($"{testPath} {solverId}"));
                    using var _ = cb.Function($"public async Task {testName}");
                    cb.Declare("string", "solver", quotedSolver);
                    cb.Declare("string?", "args", quotedArgs);
                    cb.Declare("string?", "extraFile", quotedExtraFile);
                    switch (testType)
                    {
                        case TestType.SOLVE:
                            cb.Declare("string?", "solution", quotedSolutions);
                            cb.WriteLn(
                                $"await RunSolveTest({quotedPath},solver,args,extraFile,solution);"
                            );
                            break;

                        case TestType.ANY_SOLUTION:
                            cb.Declare("string[]", "solution", quotedSolutions);
                            cb.WriteLn(
                                $"await RunAnySolutionTest({quotedPath},solver,args,extraFile,solution);"
                            );
                            break;
                    }
                }
            }
        }
        var source = cb.ToString();
        return source;
    }

    private static string QuoteSolution(string? solution)
    {
        if (solution is null)
            return "null";
        return TripleQuote(solution);
    }

    private static string QuoteSolutions(List<string> solutions)
    {
        List<string> array = [];
        foreach (var sol in solutions ?? [])
            array.Add(QuoteSolution(sol));

        string solutionsCs = $"[{string.Join(", ", array)}]";
        return solutionsCs;
    }

    private static string GetTestName(string path, string solver)
    {
        var name = path.Replace(".mzn", "");
        name = name.Replace("/", "_");
        name = name.Replace("-", "_");
        name = name.Replace(".", "");
        name = $"test_{name}_{solver}";
        return name;
    }

    static string FormatDzn(string s)
    {
        var z = s.Replace("\n", "\\n");
        z = z.Replace("\"", "\\\"");
        z = $"\"{z}\"";
        return z;
    }

    static string FormatArg(string s)
    {
        // Some extra options are passed in as quoted strings
        if (s.StartsWith('"'))
            return s;

        var z = CodeBuilder.Quote(s);
        return z;
    }

    static void WriteMessage(this CodeBuilder cb, object? msg = null)
    {
        if (msg is null)
            cb.Call("_output.WriteLine", "\"\"");
        else
            cb.Call("_output.WriteLine", msg.ToString()!);
    }

    static void WriteSection(this CodeBuilder cb) => cb.WriteMessage("new string('-',80)");

    private static (string id, bool enabled) GetSolverInfo(string solver) =>
        solver switch
        {
            "cbc" => ("coin-bc", true),
            "scip" => ("scip", false),
            "gurobi" => ("gurobi", false),
            "gecode_presolver" => ("gecode_presolver", false),
            _ => ("gecode", true)
        };
}
