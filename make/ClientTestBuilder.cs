namespace Make;

using System.Collections.Immutable;
using System.Reflection.Metadata;
using System.Text;
using MiniZinc.Build;
using MiniZinc.Tests;

public sealed class ClientTestsBuilder : CodeBuilder
{
    public readonly TestSpec Spec;
    public readonly TestType Type;
    public readonly string ClassName;
    public readonly ImmutableArray<TestCase> Tests;

    private ClientTestsBuilder(TestSpec spec, TestType type)
    {
        Spec = spec;
        Type = type;
        var typeName = type switch
        {
            TestType.SOLVE => "Solve",
            TestType.COMPILE => "Compile",
            TestType.OUTPUT_MODEL => "OutputModel",
            TestType.CHECK_AGAINST => "CheckAgainst",
            TestType.ALL_SOLUTIONS => "AllSolutions",
            TestType.UNSATISFIABLE => "Unsatisfiable",
            TestType.ERROR => "Error",
            TestType.ASSERTION_ERROR => "AssertionError",
            TestType.EVALUATION_ERROR => "EvaluationError",
            TestType.MINIZINC_ERROR => "MiniZincError",
            TestType.TYPE_ERROR => "TypeError",
            TestType.SYNTAX_ERROR => "SyntaxError",
            TestType.OUTPUT => "Output"
        };
        ClassName = $"{typeName}IntegrationTests";
        Tests = spec.TestCases.Where(tc => tc.Type == type).ToImmutableArray();
    }

    public string Build()
    {
        using (BlockComment())
        {
            WriteLn("<auto-generated>");
            WriteLn("This file has been auto generated by the following command:");
            WriteLn("dotnet run --project ./build/Make/Make.csproj --make-client-tests");
            Write("</auto-generated>");
        }

        WriteLn("#nullable enable");
        WriteLn("namespace MiniZinc.Tests;");
        NewLine();
        Attribute("NotInParallel");
        Block($"public class {ClassName} : IntegrationTests");
        NewLine();

        var testsByPath = Tests.GroupBy(tc => tc.Path).ToArray();
        foreach (var kv in testsByPath)
        {
            var path = kv.Key;
            var testCases = kv.ToArray();

            switch (Type)
            {
                case TestType.SOLVE:
                    WriteSolveTest(path, testCases);
                    break;
                // case TestType.COMPILE:
                //     WriteCompileTest();
                //     break;
                // case TestType.OUTPUT_MODEL:
                //     WriteOoutPutModelTest();
                //     break;
                // case TestType.CHECK_AGAINST:
                //     WriteCheckAgainstTest();
                //     break;
                // case TestType.ALL_SOLUTIONS:
                //     WriteAllSolutionsTest();
                //     break;
                // case TestType.UNSATISFIABLE:
                //     WriteUnsatisfiableTest();
                //     break;
                // case TestType.ERROR:
                //     WriteErrorTest();
                //     break;
                // case TestType.ASSERTION_ERROR:
                //     WriteAssertionErrorTest();
                //     break;
                // case TestType.EVALUATION_ERROR:
                //     WriteEvaluationErrorTest();
                //     break;
                // case TestType.MINIZINC_ERROR:
                //     WriteMiniZincErrorTest();
                //     break;
                // case TestType.TYPE_ERROR:
                //     WriteTypeErrorTest();
                //     break;
                // case TestType.SYNTAX_ERROR:
                //     WriteSyntaxErrorTest();
                //     break;
            }
        }
        var source = ToString();
        return source;
    }

    private static (string id, bool enabled) GetSolverInfo(string solver) =>
        solver switch
        {
            "cbc" => ("coin-bc", true),
            "scip" => ("scip", false),
            "gurobi" => ("gurobi", false),
            "gecode_presolver" => ("gecode_presolver", false),
            _ => ("gecode", true)
        };

    private void WriteSolveTest(string testSlug, TestCase[] testCases)
    {
        var qslug = Quote(testSlug);
        int i = 0;

        foreach (TestCase testCase in testCases)
        {
            string qargs = Quote(testCase.Args);
            string qsolution = testCase.Solutions switch
            {
                { Count: 1 } => QuoteSolution(testCase.Solutions[0]),
                null => "null",
                _ => throw new Exception()
            };

            if (testCase.Solvers is not { Count: > 0 } solvers)
                solvers = ["gecode"];

            if (testCase.ExtraFiles is not { Count: > 0 } extras)
                extras = [null];

            var testName = GetTestName(testSlug);

            foreach (var tsolver in solvers)
            {
                var (solver, enabled) = GetSolverInfo(tsolver);
                var qsolver = Quote(solver);
                foreach (string? extra in extras)
                {
                    var qextra = Quote(extra);
                    Attribute("Test");
                    Attribute(
                        "DisplayName",
                        Quote($"{testSlug} {solver} {qargs.Replace("\"", "")}")
                    );
                    using var _ = Function($"public async Task {testName}_{++i}");
                    Declare("string", "solver", qsolver);
                    Declare("string?", "args", qargs);
                    Declare("string?", "solution", qsolution);
                    WriteLn($"await RunSolveTest({qslug},solver,args,solution);");
                }
            }
        }
    }

    private static string QuoteSolution(string? solution)
    {
        if (solution is null)
            return "null";
        return TripleQuote(solution);
    }

    private static string QuoteSolutions(List<string> solutions)
    {
        List<string> array = [];
        foreach (var sol in solutions ?? [])
            array.Add(QuoteSolution(sol));

        string solutionsCs = $"[{string.Join(", ", array)}]";
        return solutionsCs;
    }

    private static string GetTestName(string path)
    {
        var name = path.Replace(".mzn", "");
        name = name.Replace("/", "_");
        name = name.Replace("-", "_");
        name = name.Replace(".", "");
        name = $"test_{name}";
        return name;
    }

    public static void Build(TestSpec spec, DirectoryInfo dir)
    {
        Build(dir, spec, TestType.SOLVE);
        // Build(spec, dir, TestType.COMPILE);
        // Build(spec, dir, TestType.OUTPUT_MODEL);
        // Build(spec, dir, TestType.CHECK_AGAINST);
        // Build(spec, dir, TestType.ALL_SOLUTIONS);
        // Build(spec, dir, TestType.UNSATISFIABLE);
        // Build(spec, dir, TestType.ERROR);
        // Build(spec, dir, TestType.ASSERTION_ERROR);
        // Build(spec, dir, TestType.EVALUATION_ERROR);
        // Build(spec, dir, TestType.MINIZINC_ERROR);
        // Build(spec, dir, TestType.TYPE_ERROR);
        // Build(spec, dir, TestType.SYNTAX_ERROR);
    }

    public static void Build(DirectoryInfo dir, TestSpec spec, TestType type)
    {
        var builder = new ClientTestsBuilder(spec, type);
        var source = builder.Build();
        var file = dir.JoinFile($"{builder.ClassName}.cs");
        File.WriteAllText(file.FullName, source);
    }

    private string FormatDzn(string s)
    {
        var z = s.Replace("\n", "\\n");
        z = z.Replace("\"", "\\\"");
        z = $"\"{z}\"";
        return z;
    }

    private string FormatArg(string s)
    {
        // Some extra options are passed in as quoted strings
        if (s.StartsWith('"'))
            return s;

        var z = Quote(s);
        return z;
    }

    void WriteMessage(object? msg = null)
    {
        if (msg is null)
            Call("_output.WriteLine", "\"\"");
        else
            Call("_output.WriteLine", msg.ToString()!);
    }

    void WriteSection() => WriteMessage("new string('-',80)");
}
