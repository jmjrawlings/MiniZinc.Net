/*
THIS FILE WAS GENERATED BY THE FOLLOWING COMMAND

dotnet run --project ./build/Make/Make.csproj --make-client-tests
*/
public class ClientIntegrationTests : IClassFixture<ClientFixture> {
	private readonly MiniZincClient MiniZinc;
	private readonly ITestOutputHelper _output;
	public ClientIntegrationTests(ClientFixture fixture, ITestOutputHelper output){
		MiniZinc = fixture.Client;
		_output = output;
	}
	private void Write(object? msg){
		_output.WriteLine(msg?.ToString() ?? string.Empty);
	}
	private void WriteWarning(string msg){
		Write($"WARNING - {msg}");
	}
	private void WriteError(string msg){
		Write($"ERROR - {msg}");
	}
	private void WriteSection(){
		Write(new string('-',80));
	}
	Model Compile(string path){
		Write(path);
WriteSection();
var model = Model.FromFile(path);
Write(model.SourceText);
WriteSection();
foreach (var warn in model.Warnings)
    WriteWarning(warn);
return model;	}
	async Task<SolveResult> Solve(Model model, SolveOptions options, params SolveStatus[] statuses){
		var solution = await MiniZinc.Solve(model, options);
Write(options.SolverId);
Write(solution.Command);
Write(solution.Status);
WriteSection();
var ok = false;
foreach (var status in statuses){
    if (solution.Status == status){
        ok = true;
        break;
    }
}
ok.Should().BeTrue($"{solution.Status} - {solution.Text}");
return solution;	}
	[Fact(DisplayName="unit/compilation/aggregation.mzn")]
	public async Task test_solve_unit_compilation_aggregation() {
		var solver = "gecode";
		var path = "unit/compilation/aggregation.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/compilation/annotate_bool_literal.mzn")]
	public async Task test_solve_unit_compilation_annotate_bool_literal() {
		var solver = "gecode";
		var path = "unit/compilation/annotate_bool_literal.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/compilation/annotate_from_array.mzn")]
	public async Task test_solve_unit_compilation_annotate_from_array() {
		var solver = "gecode";
		var path = "unit/compilation/annotate_from_array.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/compilation/assert_dbg_flag.mzn")]
	public async Task test_solve_unit_compilation_assert_dbg_flag() {
		var solver = "gecode";
		var path = "unit/compilation/assert_dbg_flag.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--debug");
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/compilation/assert_dbg_ignore.mzn")]
	public async Task test_solve_unit_compilation_assert_dbg_ignore() {
		var solver = "gecode";
		var path = "unit/compilation/assert_dbg_ignore.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/compilation/call_root_ctx.mzn")]
	public async Task test_solve_unit_compilation_call_root_ctx() {
		var solver = "gecode";
		var path = "unit/compilation/call_root_ctx.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/compilation/chain_compr_mult_clause.mzn")]
	public async Task test_solve_unit_compilation_chain_compr_mult_clause() {
		var solver = "gecode";
		var path = "unit/compilation/chain_compr_mult_clause.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/compilation/clause_disable_hr.mzn")]
	public async Task test_solve_unit_compilation_clause_disable_hr() {
		var solver = "gecode";
		var path = "unit/compilation/clause_disable_hr.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/compilation/commutative_cse.mzn")]
	public async Task test_solve_unit_compilation_commutative_cse() {
		var solver = "gecode";
		var path = "unit/compilation/commutative_cse.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/compilation/count_rewrite.mzn")]
	public async Task test_solve_unit_compilation_count_rewrite() {
		var solver = "gecode";
		var path = "unit/compilation/count_rewrite.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/compilation/debug_mode_false.mzn")]
	public async Task test_solve_unit_compilation_debug_mode_false() {
		var solver = "gecode";
		var path = "unit/compilation/debug_mode_false.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/compilation/debug_mode_true.mzn")]
	public async Task test_solve_unit_compilation_debug_mode_true() {
		var solver = "gecode";
		var path = "unit/compilation/debug_mode_true.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--debug");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/compilation/defines_var_cycle_breaking.mzn")]
	public async Task test_solve_unit_compilation_defines_var_cycle_breaking() {
		var solver = "gecode";
		var path = "unit/compilation/defines_var_cycle_breaking.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/compilation/float_inf_range_dom.mzn")]
	public async Task test_solve_unit_compilation_float_inf_range_dom() {
		var solver = "gecode";
		var path = "unit/compilation/float_inf_range_dom.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/compilation/has_ann.mzn")]
	public async Task test_solve_unit_compilation_has_ann() {
		var solver = "gecode";
		var path = "unit/compilation/has_ann.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/compilation/if_then_no_else.mzn")]
	public async Task test_solve_unit_compilation_if_then_no_else() {
		var solver = "gecode";
		var path = "unit/compilation/if_then_no_else.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/compilation/implied_exists_chain.mzn")]
	public async Task test_solve_unit_compilation_implied_exists_chain() {
		var solver = "gecode";
		var path = "unit/compilation/implied_exists_chain.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/compilation/implied_hr.mzn")]
	public async Task test_solve_unit_compilation_implied_hr() {
		var solver = "gecode";
		var path = "unit/compilation/implied_hr.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/compilation/int_inf_dom.mzn")]
	public async Task test_solve_unit_compilation_int_inf_dom() {
		var solver = "gecode";
		var path = "unit/compilation/int_inf_dom.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/compilation/multiple_neg.mzn")]
	public async Task test_solve_unit_compilation_multiple_neg() {
		var solver = "gecode";
		var path = "unit/compilation/multiple_neg.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/compilation/optimization.mzn")]
	public async Task test_solve_unit_compilation_optimization() {
		var solver = "gecode";
		var path = "unit/compilation/optimization.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-O0");
	}

	[Fact(DisplayName="unit/compilation/optimization.mzn")]
	public async Task test_solve_unit_compilation_optimization_case_2() {
		var solver = "gecode";
		var path = "unit/compilation/optimization.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-O1");
	}

	[Fact(DisplayName="unit/compilation/optimization.mzn")]
	public async Task test_solve_unit_compilation_optimization_case_3() {
		var solver = "gecode";
		var path = "unit/compilation/optimization.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-O2");
	}

	[Fact(DisplayName="unit/compilation/optimization.mzn")]
	public async Task test_solve_unit_compilation_optimization_case_4() {
		var solver = "gecode";
		var path = "unit/compilation/optimization.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-O3");
	}

	[Fact(DisplayName="unit/compilation/par_arg_out_of_bounds.mzn")]
	public async Task test_solve_unit_compilation_par_arg_out_of_bounds() {
		var solver = "gecode";
		var path = "unit/compilation/par_arg_out_of_bounds.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/compilation/poly_overload.mzn")]
	public async Task test_solve_unit_compilation_poly_overload() {
		var solver = "gecode";
		var path = "unit/compilation/poly_overload.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/compilation/quoted_id_flatzinc.mzn")]
	public async Task test_solve_unit_compilation_quoted_id_flatzinc() {
		var solver = "gecode";
		var path = "unit/compilation/quoted_id_flatzinc.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Theory(DisplayName="unit/compilation/set2iter.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_compilation_set2iter(string solver) {
		var path = "unit/compilation/set2iter.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/compilation/time_limit.mzn")]
	public async Task test_solve_unit_compilation_time_limit() {
		var solver = "gecode";
		var path = "unit/compilation/time_limit.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--time-limit 1");
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().Be("time limit reached");
	}

	[Theory(DisplayName="unit/division/test_div10.mzn")]
	[InlineData("gecode")]
	[InlineData("coin-bc")]
	[InlineData("highs")]
	public async Task test_solve_unit_division_test_div10(string solver) {
		var path = "unit/division/test_div10.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/division/test_div11.mzn")]
	[InlineData("gecode")]
	[InlineData("coin-bc")]
	[InlineData("highs")]
	public async Task test_solve_unit_division_test_div11(string solver) {
		var path = "unit/division/test_div11.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/division/test_div12.mzn")]
	public async Task test_solve_unit_division_test_div12() {
		var solver = "gecode";
		var path = "unit/division/test_div12.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/division/test_div8.mzn")]
	[InlineData("gecode")]
	[InlineData("coin-bc")]
	[InlineData("highs")]
	public async Task test_solve_unit_division_test_div8(string solver) {
		var path = "unit/division/test_div8.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/division/test_div_mod_bounds.mzn")]
	[InlineData("gecode")]
	[InlineData("gurobi", Skip="Solver not supported")]
	[InlineData("scip", Skip="Solver not supported")]
	public async Task test_solve_unit_division_test_div_mod_bounds(string solver) {
		var path = "unit/division/test_div_mod_bounds.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/division/test_fldiv_01.mzn")]
	[InlineData("gurobi", Skip="Solver not supported")]
	[InlineData("scip", Skip="Solver not supported")]
	public async Task test_solve_unit_division_test_fldiv_01(string solver) {
		var path = "unit/division/test_fldiv_01.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/division/test_fldiv_02.mzn")]
	[InlineData("gurobi", Skip="Solver not supported")]
	[InlineData("scip", Skip="Solver not supported")]
	public async Task test_solve_unit_division_test_fldiv_02(string solver) {
		var path = "unit/division/test_fldiv_02.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/annotated_expression_1.mzn")]
	public async Task test_solve_unit_general_annotated_expression_1() {
		var solver = "gecode";
		var path = "unit/general/annotated_expression_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/array_access_out_of_bounds_1.mzn")]
	public async Task test_solve_unit_general_array_access_out_of_bounds_1() {
		var solver = "gecode";
		var path = "unit/general/array_access_out_of_bounds_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*array access out of bounds, array `x' has index set A..B, but given index is C.*");
	}

	[Fact(DisplayName="unit/general/array_access_out_of_bounds_2.mzn")]
	public async Task test_solve_unit_general_array_access_out_of_bounds_2() {
		var solver = "gecode";
		var path = "unit/general/array_access_out_of_bounds_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*array access out of bounds, array `x' is empty.*");
	}

	[Fact(DisplayName="unit/general/array_access_record_out_of_bounds.mzn")]
	public async Task test_solve_unit_general_array_access_record_out_of_bounds() {
		var solver = "gecode";
		var path = "unit/general/array_access_record_out_of_bounds.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*array access out of bounds.*");
	}

	[Fact(DisplayName="unit/general/array_access_tuple_out_of_bounds.mzn")]
	public async Task test_solve_unit_general_array_access_tuple_out_of_bounds() {
		var solver = "gecode";
		var path = "unit/general/array_access_tuple_out_of_bounds.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*array access out of bounds.*");
	}

	[Fact(DisplayName="unit/general/array_intersect_context.mzn")]
	public async Task test_solve_unit_general_array_intersect_context() {
		var solver = "gecode";
		var path = "unit/general/array_intersect_context.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/array_param_non_array_return.mzn")]
	public async Task test_solve_unit_general_array_param_non_array_return() {
		var solver = "gecode";
		var path = "unit/general/array_param_non_array_return.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/array_union_intersect_enum.mzn")]
	public async Task test_solve_unit_general_array_union_intersect_enum() {
		var solver = "gecode";
		var path = "unit/general/array_union_intersect_enum.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/bin_pack_multiobj.mzn", Skip="Solver not supported")]
	public async Task test_solve_unit_general_bin_pack_multiobj() {
		var solver = "gurobi";
		var path = "unit/general/bin_pack_multiobj.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/builtins_arg_max.mzn")]
	public async Task test_solve_unit_general_builtins_arg_max() {
		var solver = "gecode";
		var path = "unit/general/builtins_arg_max.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/builtins_debug.mzn")]
	public async Task test_solve_unit_general_builtins_debug() {
		var solver = "gecode";
		var path = "unit/general/builtins_debug.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/comprehension_var_ub.mzn")]
	public async Task test_solve_unit_general_comprehension_var_ub() {
		var solver = "gecode";
		var path = "unit/general/comprehension_var_ub.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/cse_ctx.mzn")]
	public async Task test_solve_unit_general_cse_ctx() {
		var solver = "gecode";
		var path = "unit/general/cse_ctx.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-G std");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/enum_constructor_quoting.mzn")]
	public async Task test_solve_unit_general_enum_constructor_quoting() {
		var solver = "gecode";
		var path = "unit/general/enum_constructor_quoting.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/enum_order.mzn")]
	public async Task test_solve_unit_general_enum_order() {
		var solver = "gecode";
		var path = "unit/general/enum_order.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/enum_out_of_range_1.mzn")]
	public async Task test_solve_unit_general_enum_out_of_range_1() {
		var solver = "gecode";
		var path = "unit/general/enum_out_of_range_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*declared domain of `x' is {A}, but assigned value is B.*");
	}

	[Fact(DisplayName="unit/general/enum_out_of_range_2.mzn")]
	public async Task test_solve_unit_general_enum_out_of_range_2() {
		var solver = "gecode";
		var path = "unit/general/enum_out_of_range_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*declared domain of `x' is {A}, but assigned value is {B}.*");
	}

	[Fact(DisplayName="unit/general/eval_par_opt_set.mzn")]
	public async Task test_solve_unit_general_eval_par_opt_set() {
		var solver = "gecode";
		var path = "unit/general/eval_par_opt_set.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/fix_struct.mzn")]
	public async Task test_solve_unit_general_fix_struct() {
		var solver = "gecode";
		var path = "unit/general/fix_struct.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/function_param_out_of_range.mzn")]
	public async Task test_solve_unit_general_function_param_out_of_range() {
		var solver = "gecode";
		var path = "unit/general/function_param_out_of_range.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*declared domain of `'<unnamed argument>'' is 1..1, but assigned value is 2.*");
	}

	[Fact(DisplayName="unit/general/function_return_out_of_range.mzn")]
	public async Task test_solve_unit_general_function_return_out_of_range() {
		var solver = "gecode";
		var path = "unit/general/function_return_out_of_range.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*result of function `foo' is B, which violates function type-inst {A}.*");
	}

	[Fact(DisplayName="unit/general/function_return_out_of_range_opt.mzn")]
	public async Task test_solve_unit_general_function_return_out_of_range_opt() {
		var solver = "gecode";
		var path = "unit/general/function_return_out_of_range_opt.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*function result violates function type-inst, array contains value B which is not contained in {A}.*");
	}

	[Fact(DisplayName="unit/general/infinite_domain_bind.mzn")]
	public async Task test_solve_unit_general_infinite_domain_bind() {
		var solver = "gecode";
		var path = "unit/general/infinite_domain_bind.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/json_ignore.mzn")]
	public async Task test_solve_unit_general_json_ignore() {
		var solver = "gecode";
		var path = "unit/general/json_ignore.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/general/json_ignore.mzc.mzn\"");
		options = options.AddArgs("--data \"unit/general/json_ignore.json\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/let_struct_domain.mzn")]
	public async Task test_solve_unit_general_let_struct_domain() {
		var solver = "gecode";
		var path = "unit/general/let_struct_domain.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/general/md_exists.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_general_md_exists(string solver) {
		var path = "unit/general/md_exists.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/md_exists.mzn")]
	public async Task test_solve_unit_general_md_exists_case_2() {
		var solver = "coin-bc";
		var path = "unit/general/md_exists.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/md_forall.mzn")]
	public async Task test_solve_unit_general_md_forall() {
		var solver = "gecode";
		var path = "unit/general/md_forall.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/general/md_forall.mzn")]
	[InlineData("coin-bc")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_general_md_forall_case_2(string solver) {
		var path = "unit/general/md_forall.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/general/md_iffall.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_general_md_iffall(string solver) {
		var path = "unit/general/md_iffall.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/md_iffall.mzn")]
	public async Task test_solve_unit_general_md_iffall_case_2() {
		var solver = "coin-bc";
		var path = "unit/general/md_iffall.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/general/md_product_int.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_general_md_product_int(string solver) {
		var path = "unit/general/md_product_int.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/md_sum_float.mzn")]
	public async Task test_solve_unit_general_md_sum_float() {
		var solver = "gecode";
		var path = "unit/general/md_sum_float.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/md_sum_float.mzn")]
	public async Task test_solve_unit_general_md_sum_float_case_2() {
		var solver = "chuffed";
		var path = "unit/general/md_sum_float.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/general/md_sum_int.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_general_md_sum_int(string solver) {
		var path = "unit/general/md_sum_int.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/general/md_xorall.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_general_md_xorall(string solver) {
		var path = "unit/general/md_xorall.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/missing_ozn_decl.mzn")]
	public async Task test_solve_unit_general_missing_ozn_decl() {
		var solver = "gecode";
		var path = "unit/general/missing_ozn_decl.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/general/mortgage.mzn")]
	[InlineData("gecode")]
	[InlineData("coin-bc")]
	[InlineData("highs")]
	public async Task test_solve_unit_general_mortgage(string solver) {
		var path = "unit/general/mortgage.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/overload_bottom.mzn")]
	public async Task test_solve_unit_general_overload_bottom() {
		var solver = "gecode";
		var path = "unit/general/overload_bottom.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/param_out_of_range_float.mzn")]
	public async Task test_solve_unit_general_param_out_of_range_float() {
		var solver = "gecode";
		var path = "unit/general/param_out_of_range_float.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*declared domain of `x' is -infinity..-1.0 union 1.0..infinity, but assigned value is 0.0.*");
	}

	[Fact(DisplayName="unit/general/param_out_of_range_int.mzn")]
	public async Task test_solve_unit_general_param_out_of_range_int() {
		var solver = "gecode";
		var path = "unit/general/param_out_of_range_int.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*declared domain of `x' is -infinity..-1 union 1..infinity, but assigned value is 0.*");
	}

	[Fact(DisplayName="unit/general/pow_1.mzn")]
	public async Task test_solve_unit_general_pow_1() {
		var solver = "gecode";
		var path = "unit/general/pow_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_2.mzn")]
	public async Task test_solve_unit_general_pow_2() {
		var solver = "gecode";
		var path = "unit/general/pow_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-D \"x = -2..2; y = 0\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_2.mzn")]
	public async Task test_solve_unit_general_pow_2_case_2() {
		var solver = "gecode";
		var path = "unit/general/pow_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-D \"x = -2..2; y = 1\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_2.mzn")]
	public async Task test_solve_unit_general_pow_2_case_3() {
		var solver = "gecode";
		var path = "unit/general/pow_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-D \"x = 0..1; y = 2\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_2.mzn")]
	public async Task test_solve_unit_general_pow_2_case_4() {
		var solver = "gecode";
		var path = "unit/general/pow_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-D \"x = -1..1; y = 3\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_2.mzn")]
	public async Task test_solve_unit_general_pow_2_case_5() {
		var solver = "gecode";
		var path = "unit/general/pow_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-D \"x = 1..3; y = -1\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_2.mzn")]
	public async Task test_solve_unit_general_pow_2_case_6() {
		var solver = "gecode";
		var path = "unit/general/pow_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-D \"x = 2..3; y = 2\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_2.mzn")]
	public async Task test_solve_unit_general_pow_2_case_7() {
		var solver = "gecode";
		var path = "unit/general/pow_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-D \"x = -1..2; y = -2\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_3.mzn")]
	public async Task test_solve_unit_general_pow_3() {
		var solver = "gecode";
		var path = "unit/general/pow_3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-D \"x = 0..1; y = 0..1\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_3.mzn")]
	public async Task test_solve_unit_general_pow_3_case_2() {
		var solver = "gecode";
		var path = "unit/general/pow_3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-D \"x = 0..1; y = 1..2\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_3.mzn")]
	public async Task test_solve_unit_general_pow_3_case_3() {
		var solver = "gecode";
		var path = "unit/general/pow_3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-D \"x = -1..2; y = 0..2\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_3.mzn")]
	public async Task test_solve_unit_general_pow_3_case_4() {
		var solver = "gecode";
		var path = "unit/general/pow_3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-D \"x = -2..2 diff {0}; y = -2..-1\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_3.mzn")]
	public async Task test_solve_unit_general_pow_3_case_5() {
		var solver = "gecode";
		var path = "unit/general/pow_3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-D \"x = -2..2 diff {0}; y = -1..2\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_3.mzn")]
	public async Task test_solve_unit_general_pow_3_case_6() {
		var solver = "gecode";
		var path = "unit/general/pow_3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-D \"x = -1..1; y = -1..1\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_4.mzn")]
	public async Task test_solve_unit_general_pow_4() {
		var solver = "gecode";
		var path = "unit/general/pow_4.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/pow_bounds.mzn")]
	public async Task test_solve_unit_general_pow_bounds() {
		var solver = "gecode";
		var path = "unit/general/pow_bounds.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/quoted_id_1.mzn")]
	public async Task test_solve_unit_general_quoted_id_1() {
		var solver = "gecode";
		var path = "unit/general/quoted_id_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/quoted_id_2.mzn")]
	public async Task test_solve_unit_general_quoted_id_2() {
		var solver = "gecode";
		var path = "unit/general/quoted_id_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/quoted_id_3.mzn")]
	public async Task test_solve_unit_general_quoted_id_3() {
		var solver = "gecode";
		var path = "unit/general/quoted_id_3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/quoted_id_4.mzn")]
	public async Task test_solve_unit_general_quoted_id_4() {
		var solver = "gecode";
		var path = "unit/general/quoted_id_4.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/range_var_enum.mzn")]
	public async Task test_solve_unit_general_range_var_enum() {
		var solver = "gecode";
		var path = "unit/general/range_var_enum.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/stack_overflow.mzn")]
	public async Task test_solve_unit_general_stack_overflow() {
		var solver = "gecode";
		var path = "unit/general/stack_overflow.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*stack overflow.*");
	}

	[Theory(DisplayName="unit/general/test-search1.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	[InlineData("coin-bc")]
	public async Task test_solve_unit_general_test_search1(string solver) {
		var path = "unit/general/test-search1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/test_mod_bounds.mzn")]
	public async Task test_solve_unit_general_test_mod_bounds() {
		var solver = "gecode";
		var path = "unit/general/test_mod_bounds.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/general/test_negated_and.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_general_test_negated_and(string solver) {
		var path = "unit/general/test_negated_and.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/general/test_negated_and_or.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_general_test_negated_and_or(string solver) {
		var path = "unit/general/test_negated_and_or.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/general/test_negated_let_good_2.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_general_test_negated_let_good_2(string solver) {
		var path = "unit/general/test_negated_let_good_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/general/test_negated_or.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_general_test_negated_or(string solver) {
		var path = "unit/general/test_negated_or.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/general/test_queens.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_general_test_queens(string solver) {
		var path = "unit/general/test_queens.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/test_rounding_a.mzn")]
	public async Task test_solve_unit_general_test_rounding_a() {
		var solver = "gecode";
		var path = "unit/general/test_rounding_a.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/test_rounding_b.mzn")]
	public async Task test_solve_unit_general_test_rounding_b() {
		var solver = "gecode";
		var path = "unit/general/test_rounding_b.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/test_rounding_c.mzn")]
	public async Task test_solve_unit_general_test_rounding_c() {
		var solver = "gecode";
		var path = "unit/general/test_rounding_c.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/general/test_same.mzn")]
	[InlineData("gecode")]
	[InlineData("coin-bc")]
	[InlineData("highs")]
	public async Task test_solve_unit_general_test_same(string solver) {
		var path = "unit/general/test_same.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/test_set_lt_1.mzn")]
	public async Task test_solve_unit_general_test_set_lt_1() {
		var solver = "chuffed";
		var path = "unit/general/test_set_lt_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/test_set_lt_2.mzn")]
	public async Task test_solve_unit_general_test_set_lt_2() {
		var solver = "chuffed";
		var path = "unit/general/test_set_lt_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/general/test_set_lt_2.mzn")]
	public async Task test_solve_unit_general_test_set_lt_2_case_2() {
		var solver = "coin-bc";
		var path = "unit/general/test_set_lt_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/general/test_set_lt_3.mzn")]
	[InlineData("chuffed")]
	[InlineData("coin-bc")]
	[InlineData("highs")]
	public async Task test_solve_unit_general_test_set_lt_3(string solver) {
		var path = "unit/general/test_set_lt_3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/general/test_times_int_float_eq.mzn")]
	[InlineData("gurobi", Skip="Solver not supported")]
	[InlineData("scip", Skip="Solver not supported")]
	public async Task test_solve_unit_general_test_times_int_float_eq(string solver) {
		var path = "unit/general/test_times_int_float_eq.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-D QuadrFloat=true;QuadrIntCard=0");
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/general/test_times_int_float_eq__defaultopt.mzn")]
	[InlineData("gurobi", Skip="Solver not supported")]
	[InlineData("scip", Skip="Solver not supported")]
	public async Task test_solve_unit_general_test_times_int_float_eq__defaultopt(string solver) {
		var path = "unit/general/test_times_int_float_eq__defaultopt.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/test_to_enum.mzn")]
	public async Task test_solve_unit_general_test_to_enum() {
		var solver = "gecode";
		var path = "unit/general/test_to_enum.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/test_undefined_enum.mzn")]
	public async Task test_solve_unit_general_test_undefined_enum() {
		var solver = "gecode";
		var path = "unit/general/test_undefined_enum.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--model-check-only");
	}

	[Theory(DisplayName="unit/general/test_var_prod.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_general_test_var_prod(string solver) {
		var path = "unit/general/test_var_prod.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/general/test_var_set_element.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	[InlineData("coin-bc")]
	public async Task test_solve_unit_general_test_var_set_element(string solver) {
		var path = "unit/general/test_var_set_element.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/general/unicode_file_name_μ.mzn")]
	public async Task test_solve_unit_general_unicode_file_name_μ() {
		var solver = "gecode";
		var path = "unit/general/unicode_file_name_μ.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/typecheck_globals.mzn")]
	[InlineData("chuffed")]
	[InlineData("gecode")]
	[InlineData("gecode_presolver")]
	[InlineData("highs")]
	public async Task test_solve_unit_globals_typecheck_globals(string solver) {
		var path = "unit/globals/typecheck_globals.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/json/anon_enum_json.mzn")]
	public async Task test_solve_unit_json_anon_enum_json() {
		var solver = "gecode";
		var path = "unit/json/anon_enum_json.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/anon_enum_json.json\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/json/anon_enum_json.mzn")]
	public async Task test_solve_unit_json_anon_enum_json_case_2() {
		var solver = "gecode";
		var path = "unit/json/anon_enum_json.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/anon_enum_json_err.json\"");
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*invalid enum object.*");
	}

	[Fact(DisplayName="unit/json/coerce_enum_str.mzn")]
	public async Task test_solve_unit_json_coerce_enum_str() {
		var solver = "gecode";
		var path = "unit/json/coerce_enum_str.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/coerce_enum_str.json\"");
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/json/coerce_enum_str_err.mzn")]
	public async Task test_solve_unit_json_coerce_enum_str_err() {
		var solver = "gecode";
		var path = "unit/json/coerce_enum_str_err.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/coerce_enum_str_err.json\"");
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*has invalid type-inst.*");
	}

	[Fact(DisplayName="unit/json/coerce_indices.mzn")]
	public async Task test_solve_unit_json_coerce_indices() {
		var solver = "gecode";
		var path = "unit/json/coerce_indices.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/coerce_indices.json\"");
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/json/coerce_set.mzn")]
	public async Task test_solve_unit_json_coerce_set() {
		var solver = "gecode";
		var path = "unit/json/coerce_set.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/coerce_set.json\"");
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/json/enum_constructor_basic.mzn")]
	public async Task test_solve_unit_json_enum_constructor_basic() {
		var solver = "gecode";
		var path = "unit/json/enum_constructor_basic.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/enum_constructor_basic.json\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/json/enum_constructor_basic_2.mzn")]
	public async Task test_solve_unit_json_enum_constructor_basic_2() {
		var solver = "gecode";
		var path = "unit/json/enum_constructor_basic_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/enum_constructor_basic_2.json\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/json/enum_constructor_int.mzn")]
	public async Task test_solve_unit_json_enum_constructor_int() {
		var solver = "gecode";
		var path = "unit/json/enum_constructor_int.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/enum_constructor_int.json\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/json/enum_constructor_nested.mzn")]
	public async Task test_solve_unit_json_enum_constructor_nested() {
		var solver = "gecode";
		var path = "unit/json/enum_constructor_nested.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/enum_constructor_nested.json\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/json/enum_escaping.mzn")]
	public async Task test_solve_unit_json_enum_escaping() {
		var solver = "gecode";
		var path = "unit/json/enum_escaping.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/json/float_json_exponent.mzn")]
	public async Task test_solve_unit_json_float_json_exponent() {
		var solver = "gecode";
		var path = "unit/json/float_json_exponent.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/float_json_exponent.json\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/json/json_array2d_set.mzn")]
	public async Task test_solve_unit_json_json_array2d_set() {
		var solver = "gecode";
		var path = "unit/json/json_array2d_set.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/json_array2d_set.json\"");
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/json/json_enum_def.mzn")]
	public async Task test_solve_unit_json_json_enum_def() {
		var solver = "gecode";
		var path = "unit/json/json_enum_def.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/json_enum_def.json\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/json/json_input_1.mzn")]
	public async Task test_solve_unit_json_json_input_1() {
		var solver = "gecode";
		var path = "unit/json/json_input_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/json_input_1.json\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/json/json_unicode_escapes.mzn")]
	public async Task test_solve_unit_json_json_unicode_escapes() {
		var solver = "gecode";
		var path = "unit/json/json_unicode_escapes.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/json_unicode_escapes.json\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/json/mult_dim_enum.mzn")]
	public async Task test_solve_unit_json_mult_dim_enum() {
		var solver = "gecode";
		var path = "unit/json/mult_dim_enum.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/mult_dim_enum.json\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/json/record_json_input.mzn")]
	public async Task test_solve_unit_json_record_json_input() {
		var solver = "gecode";
		var path = "unit/json/record_json_input.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/record_json_input.json\"");
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/json/tuple_json_input.mzn")]
	public async Task test_solve_unit_json_tuple_json_input() {
		var solver = "gecode";
		var path = "unit/json/tuple_json_input.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/json/tuple_json_input.json\"");
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/on_restart/complete.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_on_restart_complete(string solver) {
		var path = "unit/on_restart/complete.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--restart constant");
		options = options.AddArgs("--restart-base 100");
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/on_restart/last_val_bool.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_on_restart_last_val_bool(string solver) {
		var path = "unit/on_restart/last_val_bool.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--restart constant");
		options = options.AddArgs("--restart-base 100");
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/on_restart/last_val_float.mzn")]
	public async Task test_solve_unit_on_restart_last_val_float() {
		var solver = "gecode";
		var path = "unit/on_restart/last_val_float.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--restart constant");
		options = options.AddArgs("--restart-base 100");
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/on_restart/last_val_int.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_on_restart_last_val_int(string solver) {
		var path = "unit/on_restart/last_val_int.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--restart constant");
		options = options.AddArgs("--restart-base 100");
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/on_restart/last_val_set.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_on_restart_last_val_set(string solver) {
		var path = "unit/on_restart/last_val_set.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--restart constant");
		options = options.AddArgs("--restart-base 100");
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/on_restart/sol_bool.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_on_restart_sol_bool(string solver) {
		var path = "unit/on_restart/sol_bool.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--restart constant");
		options = options.AddArgs("--restart-base 100");
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/on_restart/sol_float.mzn")]
	public async Task test_solve_unit_on_restart_sol_float() {
		var solver = "gecode";
		var path = "unit/on_restart/sol_float.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--restart constant");
		options = options.AddArgs("--restart-base 100");
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/on_restart/sol_int.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_on_restart_sol_int(string solver) {
		var path = "unit/on_restart/sol_int.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--restart constant");
		options = options.AddArgs("--restart-base 100");
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/on_restart/sol_set.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_on_restart_sol_set(string solver) {
		var path = "unit/on_restart/sol_set.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--restart constant");
		options = options.AddArgs("--restart-base 100");
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/optional/conj_absent_1.mzn")]
	public async Task test_solve_unit_optional_conj_absent_1() {
		var solver = "gecode";
		var path = "unit/optional/conj_absent_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/optional/conj_absent_2.mzn")]
	public async Task test_solve_unit_optional_conj_absent_2() {
		var solver = "gecode";
		var path = "unit/optional/conj_absent_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/optional/fn_return_array_absent.mzn")]
	public async Task test_solve_unit_optional_fn_return_array_absent() {
		var solver = "gecode";
		var path = "unit/optional/fn_return_array_absent.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/optional/opt_array_access.mzn")]
	public async Task test_solve_unit_optional_opt_array_access() {
		var solver = "gecode";
		var path = "unit/optional/opt_array_access.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/optional/test-opt-bool-2.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_optional_test_opt_bool_2(string solver) {
		var path = "unit/optional/test-opt-bool-2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/optional/test-opt-bool-3.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_optional_test_opt_bool_3(string solver) {
		var path = "unit/optional/test-opt-bool-3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/optional/test-opt-bool-4.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_optional_test_opt_bool_4(string solver) {
		var path = "unit/optional/test-opt-bool-4.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/optional/test-opt-bool-5.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_optional_test_opt_bool_5(string solver) {
		var path = "unit/optional/test-opt-bool-5.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/optional/test-opt-bool-6.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_optional_test_opt_bool_6(string solver) {
		var path = "unit/optional/test-opt-bool-6.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/optional/test-opt-float-1.mzn")]
	[InlineData("gecode")]
	[InlineData("coin-bc")]
	[InlineData("highs")]
	public async Task test_solve_unit_optional_test_opt_float_1(string solver) {
		var path = "unit/optional/test-opt-float-1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/optional/test-opt-if-then-else.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_optional_test_opt_if_then_else(string solver) {
		var path = "unit/optional/test-opt-if-then-else.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/optional/test-opt-int-2.mzn")]
	public async Task test_solve_unit_optional_test_opt_int_2() {
		var solver = "gecode";
		var path = "unit/optional/test-opt-int-2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/optional/test-opt-int-3.mzn")]
	public async Task test_solve_unit_optional_test_opt_int_3() {
		var solver = "gecode";
		var path = "unit/optional/test-opt-int-3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/optional/test_bug_456.mzn")]
	public async Task test_solve_unit_optional_test_bug_456() {
		var solver = "gecode";
		var path = "unit/optional/test_bug_456.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/optional/test_count_set.mzn")]
	public async Task test_solve_unit_optional_test_count_set() {
		var solver = "gecode";
		var path = "unit/optional/test_count_set.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/optional/test_deopt_absent.mzn")]
	public async Task test_solve_unit_optional_test_deopt_absent() {
		var solver = "gecode";
		var path = "unit/optional/test_deopt_absent.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/optional/test_if_then_else_opt_bool.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_optional_test_if_then_else_opt_bool(string solver) {
		var path = "unit/optional/test_if_then_else_opt_bool.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/optional/test_if_then_else_opt_float.mzn")]
	public async Task test_solve_unit_optional_test_if_then_else_opt_float() {
		var solver = "gecode";
		var path = "unit/optional/test_if_then_else_opt_float.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/optional/test_if_then_else_opt_int.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_optional_test_if_then_else_opt_int(string solver) {
		var path = "unit/optional/test_if_then_else_opt_int.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/optional/test_if_then_else_var_opt_bool.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_optional_test_if_then_else_var_opt_bool(string solver) {
		var path = "unit/optional/test_if_then_else_var_opt_bool.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/optional/test_if_then_else_var_opt_float.mzn")]
	public async Task test_solve_unit_optional_test_if_then_else_var_opt_float() {
		var solver = "gecode";
		var path = "unit/optional/test_if_then_else_var_opt_float.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/optional/test_if_then_else_var_opt_int.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_optional_test_if_then_else_var_opt_int(string solver) {
		var path = "unit/optional/test_if_then_else_var_opt_int.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/optional/test_optional_not_absent.mzn")]
	[InlineData("chuffed")]
	[InlineData("gecode")]
	public async Task test_solve_unit_optional_test_optional_not_absent(string solver) {
		var path = "unit/optional/test_optional_not_absent.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/optional/test_opt_comprehension.mzn")]
	public async Task test_solve_unit_optional_test_opt_comprehension() {
		var solver = "gecode";
		var path = "unit/optional/test_opt_comprehension.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/optional/test_opt_dom_empty.mzn")]
	public async Task test_solve_unit_optional_test_opt_dom_empty() {
		var solver = "gecode";
		var path = "unit/optional/test_opt_dom_empty.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/optional/test_opt_dom_empty_no_absent_zero.mzn")]
	public async Task test_solve_unit_optional_test_opt_dom_empty_no_absent_zero() {
		var solver = "gecode";
		var path = "unit/optional/test_opt_dom_empty_no_absent_zero.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/output/arg-reif-output.mzn")]
	public async Task test_solve_unit_output_arg_reif_output() {
		var solver = "gecode";
		var path = "unit/output/arg-reif-output.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/array_of_array.mzn")]
	public async Task test_solve_unit_output_array_of_array() {
		var solver = "gecode";
		var path = "unit/output/array_of_array.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/output/ctx_ann.mzn")]
	public async Task test_solve_unit_output_ctx_ann() {
		var solver = "gecode";
		var path = "unit/output/ctx_ann.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/dzn_output_array.mzn")]
	public async Task test_solve_unit_output_dzn_output_array() {
		var solver = "gecode";
		var path = "unit/output/dzn_output_array.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/output/enum_constructor_functions.mzn")]
	public async Task test_solve_unit_output_enum_constructor_functions() {
		var solver = "gecode";
		var path = "unit/output/enum_constructor_functions.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/output/json_ann.mzn")]
	public async Task test_solve_unit_output_json_ann() {
		var solver = "gecode";
		var path = "unit/output/json_ann.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/local_output.mzn")]
	public async Task test_solve_unit_output_local_output() {
		var solver = "gecode";
		var path = "unit/output/local_output.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_annotations_1.mzn")]
	public async Task test_solve_unit_output_output_annotations_1() {
		var solver = "gecode";
		var path = "unit/output/output_annotations_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_annotations_2.mzn")]
	public async Task test_solve_unit_output_output_annotations_2() {
		var solver = "gecode";
		var path = "unit/output/output_annotations_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_annotations_3.mzn")]
	public async Task test_solve_unit_output_output_annotations_3() {
		var solver = "gecode";
		var path = "unit/output/output_annotations_3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_annotations_4.mzn")]
	public async Task test_solve_unit_output_output_annotations_4() {
		var solver = "gecode";
		var path = "unit/output/output_annotations_4.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_sections_1.mzn")]
	public async Task test_solve_unit_output_output_sections_1() {
		var solver = "gecode";
		var path = "unit/output/output_sections_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_sections_1.mzn")]
	public async Task test_solve_unit_output_output_sections_1_case_2() {
		var solver = "gecode";
		var path = "unit/output/output_sections_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--only-sections foo,bar");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_sections_1.mzn")]
	public async Task test_solve_unit_output_output_sections_1_case_3() {
		var solver = "gecode";
		var path = "unit/output/output_sections_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--not-sections foo,bar");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_sections_2.mzn")]
	public async Task test_solve_unit_output_output_sections_2() {
		var solver = "gecode";
		var path = "unit/output/output_sections_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_sections_2.mzn")]
	public async Task test_solve_unit_output_output_sections_2_case_2() {
		var solver = "gecode";
		var path = "unit/output/output_sections_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--only-sections foo,bar");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_sections_2.mzn")]
	public async Task test_solve_unit_output_output_sections_2_case_3() {
		var solver = "gecode";
		var path = "unit/output/output_sections_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--not-sections foo,bar");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_sections_3.mzn")]
	public async Task test_solve_unit_output_output_sections_3() {
		var solver = "gecode";
		var path = "unit/output/output_sections_3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_sections_4.mzn")]
	public async Task test_solve_unit_output_output_sections_4() {
		var solver = "gecode";
		var path = "unit/output/output_sections_4.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_sections_5.mzn")]
	public async Task test_solve_unit_output_output_sections_5() {
		var solver = "gecode";
		var path = "unit/output/output_sections_5.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_sections_6.mzn")]
	public async Task test_solve_unit_output_output_sections_6() {
		var solver = "gecode";
		var path = "unit/output/output_sections_6.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/output_sections_7.mzn")]
	public async Task test_solve_unit_output_output_sections_7() {
		var solver = "gecode";
		var path = "unit/output/output_sections_7.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/output/quoted_id_ozn.mzn")]
	public async Task test_solve_unit_output_quoted_id_ozn() {
		var solver = "gecode";
		var path = "unit/output/quoted_id_ozn.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/output/record_access_printing.mzn")]
	public async Task test_solve_unit_output_record_access_printing() {
		var solver = "gecode";
		var path = "unit/output/record_access_printing.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Theory(DisplayName="unit/output/test-in-output.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_output_test_in_output(string solver) {
		var path = "unit/output/test-in-output.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/output/var_enum.mzn")]
	public async Task test_solve_unit_output_var_enum() {
		var solver = "gecode";
		var path = "unit/output/var_enum.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/param_file/param_file_array.mzn")]
	public async Task test_solve_unit_param_file_param_file_array() {
		var solver = "gecode";
		var path = "unit/param_file/param_file_array.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--param-file ./spec/unit/param_file/param_file_array.json");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/param_file/param_file_blacklist.mzn")]
	public async Task test_solve_unit_param_file_param_file_blacklist() {
		var solver = "gecode";
		var path = "unit/param_file/param_file_blacklist.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/param_file/param_file_blacklist_1.mpc\"");
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*not allowed in configuration file.*");
	}

	[Fact(DisplayName="unit/param_file/param_file_blacklist.mzn")]
	public async Task test_solve_unit_param_file_param_file_blacklist_case_2() {
		var solver = "gecode";
		var path = "unit/param_file/param_file_blacklist.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/param_file/param_file_blacklist_2.mpc\"");
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*not allowed in configuration file.*");
	}

	[Fact(DisplayName="unit/param_file/param_file_nested_object.mzn")]
	public async Task test_solve_unit_param_file_param_file_nested_object() {
		var solver = "gecode";
		var path = "unit/param_file/param_file_nested_object.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/param_file/param_file_nested_object.mpc\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/param_file/param_file_recursive.mzn")]
	public async Task test_solve_unit_param_file_param_file_recursive() {
		var solver = "gecode";
		var path = "unit/param_file/param_file_recursive.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/param_file/param_file_recursive.mpc\"");
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*Cyclic parameter configuration file.*");
	}

	[Fact(DisplayName="unit/param_file/param_file_resolution.mzn")]
	public async Task test_solve_unit_param_file_param_file_resolution() {
		var solver = "gecode";
		var path = "unit/param_file/param_file_resolution.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/param_file/param_file_resolution.mpc\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/arg-reif-array-float.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_arg_reif_array_float(string solver) {
		var path = "unit/regression/arg-reif-array-float.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/regression/arg-reif-array-int.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_arg_reif_array_int(string solver) {
		var path = "unit/regression/arg-reif-array-int.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/regression/arg-reif-float.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_arg_reif_float(string solver) {
		var path = "unit/regression/arg-reif-float.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/regression/arg-reif-int-set.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_arg_reif_int_set(string solver) {
		var path = "unit/regression/arg-reif-int-set.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/regression/arg-reif-int.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_arg_reif_int(string solver) {
		var path = "unit/regression/arg-reif-int.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/array_of_empty_sets.mzn")]
	public async Task test_solve_unit_regression_array_of_empty_sets() {
		var solver = "gecode";
		var path = "unit/regression/array_of_empty_sets.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/regression/array_set_element_nosets.mzn")]
	[InlineData("chuffed")]
	[InlineData("coin-bc")]
	[InlineData("highs")]
	public async Task test_solve_unit_regression_array_set_element_nosets(string solver) {
		var path = "unit/regression/array_set_element_nosets.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/array_var_set_element_nosets.mzn")]
	[InlineData("chuffed")]
	[InlineData("coin-bc")]
	[InlineData("highs")]
	public async Task test_solve_unit_regression_array_var_set_element_nosets(string solver) {
		var path = "unit/regression/array_var_set_element_nosets.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/assign_reverse_map.mzn")]
	public async Task test_solve_unit_regression_assign_reverse_map() {
		var solver = "gecode";
		var path = "unit/regression/assign_reverse_map.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/bind-defines-var.mzn")]
	public async Task test_solve_unit_regression_bind_defines_var() {
		var solver = "gecode";
		var path = "unit/regression/bind-defines-var.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-G std");
		var solution = await Solve(model, options, SolveStatus.Unsatisfiable);
	}

	[Fact(DisplayName="unit/regression/binop_mult_gclock.mzn")]
	public async Task test_solve_unit_regression_binop_mult_gclock() {
		var solver = "gecode";
		var path = "unit/regression/binop_mult_gclock.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/regression/bounds_for_linear_01_max_0.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	[InlineData("coin-bc")]
	[InlineData("highs")]
	public async Task test_solve_unit_regression_bounds_for_linear_01_max_0(string solver) {
		var path = "unit/regression/bounds_for_linear_01_max_0.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/bounds_for_linear_01_max_1.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	[InlineData("coin-bc")]
	[InlineData("highs")]
	public async Task test_solve_unit_regression_bounds_for_linear_01_max_1(string solver) {
		var path = "unit/regression/bounds_for_linear_01_max_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/bounds_for_linear_01_min_0.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	[InlineData("coin-bc")]
	[InlineData("highs")]
	public async Task test_solve_unit_regression_bounds_for_linear_01_min_0(string solver) {
		var path = "unit/regression/bounds_for_linear_01_min_0.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/bounds_for_linear_01_min_1.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	[InlineData("coin-bc")]
	[InlineData("highs")]
	public async Task test_solve_unit_regression_bounds_for_linear_01_min_1(string solver) {
		var path = "unit/regression/bounds_for_linear_01_min_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/bug110.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_bug110(string solver) {
		var path = "unit/regression/bug110.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/bug131.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_bug131(string solver) {
		var path = "unit/regression/bug131.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/regression/bug212.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_bug212(string solver) {
		var path = "unit/regression/bug212.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/regression/bug222.mzn")]
	[InlineData("coin-bc")]
	[InlineData("highs")]
	public async Task test_solve_unit_regression_bug222(string solver) {
		var path = "unit/regression/bug222.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/bug244.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_bug244(string solver) {
		var path = "unit/regression/bug244.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/bug269.mzn")]
	public async Task test_solve_unit_regression_bug269() {
		var solver = "gecode";
		var path = "unit/regression/bug269.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/bug284.mzn")]
	public async Task test_solve_unit_regression_bug284() {
		var solver = "gecode";
		var path = "unit/regression/bug284.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/bug318_orig.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_bug318_orig(string solver) {
		var path = "unit/regression/bug318_orig.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/bug335.mzn")]
	public async Task test_solve_unit_regression_bug335() {
		var solver = "gecode";
		var path = "unit/regression/bug335.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/bug380.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_bug380(string solver) {
		var path = "unit/regression/bug380.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/bug532.mzn")]
	public async Task test_solve_unit_regression_bug532() {
		var solver = "gecode";
		var path = "unit/regression/bug532.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/bug534.mzn")]
	public async Task test_solve_unit_regression_bug534() {
		var solver = "gecode";
		var path = "unit/regression/bug534.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/bug536.mzn")]
	public async Task test_solve_unit_regression_bug536() {
		var solver = "gecode";
		var path = "unit/regression/bug536.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-O2");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/bug552.mzn")]
	public async Task test_solve_unit_regression_bug552() {
		var solver = "gecode";
		var path = "unit/regression/bug552.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/bug565.mzn")]
	public async Task test_solve_unit_regression_bug565() {
		var solver = "gecode";
		var path = "unit/regression/bug565.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/bug570.mzn")]
	public async Task test_solve_unit_regression_bug570() {
		var solver = "gecode";
		var path = "unit/regression/bug570.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/regression/bug635.mzn")]
	public async Task test_solve_unit_regression_bug635() {
		var solver = "gecode";
		var path = "unit/regression/bug635.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-O2");
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/regression/bug67.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_bug67(string solver) {
		var path = "unit/regression/bug67.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/bug82.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_bug82(string solver) {
		var path = "unit/regression/bug82.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/bug_629.mzn")]
	public async Task test_solve_unit_regression_bug_629() {
		var solver = "coin-bc";
		var path = "unit/regression/bug_629.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-O1");
	}

	[Fact(DisplayName="unit/regression/bug_629.mzn")]
	public async Task test_solve_unit_regression_bug_629_case_2() {
		var solver = "coin-bc";
		var path = "unit/regression/bug_629.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-O2");
	}

	[Fact(DisplayName="unit/regression/bug_empty_enum_extension.mzn")]
	public async Task test_solve_unit_regression_bug_empty_enum_extension() {
		var solver = "gecode";
		var path = "unit/regression/bug_empty_enum_extension.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/bug_opt_polymorphic.mzn")]
	public async Task test_solve_unit_regression_bug_opt_polymorphic() {
		var solver = "gecode";
		var path = "unit/regression/bug_opt_polymorphic.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/checker_mzn_check_var.mzn")]
	public async Task test_solve_unit_regression_checker_mzn_check_var() {
		var solver = "gecode";
		var path = "unit/regression/checker_mzn_check_var.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/regression/checker_mzn_check_var.mzc.mzn\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/checker_opt.mzn")]
	public async Task test_solve_unit_regression_checker_opt() {
		var solver = "gecode";
		var path = "unit/regression/checker_opt.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/regression/checker_opt.mzc.mzn\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/checker_params.mzn")]
	public async Task test_solve_unit_regression_checker_params() {
		var solver = "gecode";
		var path = "unit/regression/checker_params.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/regression/checker_params.mzc.mzn\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/checker_same_var.mzn")]
	public async Task test_solve_unit_regression_checker_same_var() {
		var solver = "gecode";
		var path = "unit/regression/checker_same_var.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/regression/checker_same_var.mzc.mzn\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/checker_var_bug.mzn")]
	public async Task test_solve_unit_regression_checker_var_bug() {
		var solver = "gecode";
		var path = "unit/regression/checker_var_bug.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/regression/checker_var_bug.mzc.mzn\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/coercion_par.mzn")]
	public async Task test_solve_unit_regression_coercion_par() {
		var solver = "gecode";
		var path = "unit/regression/coercion_par.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/constructor_of_set.mzn")]
	public async Task test_solve_unit_regression_constructor_of_set() {
		var solver = "gecode";
		var path = "unit/regression/constructor_of_set.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/cse_array_lit.mzn")]
	public async Task test_solve_unit_regression_cse_array_lit() {
		var solver = "gecode";
		var path = "unit/regression/cse_array_lit.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/regression/cyclic_include.mzn")]
	public async Task test_solve_unit_regression_cyclic_include() {
		var solver = "gecode";
		var path = "unit/regression/cyclic_include.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/regression/enigma_1568.mzn")]
	public async Task test_solve_unit_regression_enigma_1568() {
		var solver = "gecode";
		var path = "unit/regression/enigma_1568.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/flatten_comp_in.mzn")]
	public async Task test_solve_unit_regression_flatten_comp_in() {
		var solver = "gecode";
		var path = "unit/regression/flatten_comp_in.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/flat_set_lit.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_flat_set_lit(string solver) {
		var path = "unit/regression/flat_set_lit.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/float_ceil_floor.mzn")]
	public async Task test_solve_unit_regression_float_ceil_floor() {
		var solver = "gecode";
		var path = "unit/regression/float_ceil_floor.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/float_opt_crash.mzn")]
	public async Task test_solve_unit_regression_float_opt_crash() {
		var solver = "gecode";
		var path = "unit/regression/float_opt_crash.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github537.mzn")]
	public async Task test_solve_unit_regression_github537() {
		var solver = "gecode";
		var path = "unit/regression/github537.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_638_reduced.mzn")]
	public async Task test_solve_unit_regression_github_638_reduced() {
		var solver = "gecode";
		var path = "unit/regression/github_638_reduced.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_639_part1.mzn")]
	public async Task test_solve_unit_regression_github_639_part1() {
		var solver = "gecode";
		var path = "unit/regression/github_639_part1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_639_part2.mzn")]
	public async Task test_solve_unit_regression_github_639_part2() {
		var solver = "gecode";
		var path = "unit/regression/github_639_part2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_644_a.mzn")]
	public async Task test_solve_unit_regression_github_644_a() {
		var solver = "gecode";
		var path = "unit/regression/github_644_a.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_644_b.mzn")]
	public async Task test_solve_unit_regression_github_644_b() {
		var solver = "gecode";
		var path = "unit/regression/github_644_b.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_644_c.mzn")]
	public async Task test_solve_unit_regression_github_644_c() {
		var solver = "gecode";
		var path = "unit/regression/github_644_c.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_644_d.mzn")]
	public async Task test_solve_unit_regression_github_644_d() {
		var solver = "gecode";
		var path = "unit/regression/github_644_d.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_644_e.mzn")]
	public async Task test_solve_unit_regression_github_644_e() {
		var solver = "gecode";
		var path = "unit/regression/github_644_e.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_646.mzn")]
	public async Task test_solve_unit_regression_github_646() {
		var solver = "gecode";
		var path = "unit/regression/github_646.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_648_par_array_decl.mzn")]
	public async Task test_solve_unit_regression_github_648_par_array_decl() {
		var solver = "gecode";
		var path = "unit/regression/github_648_par_array_decl.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*declared domain of `x[1]' is 1..3, but assigned value is 0.*");
	}

	[Fact(DisplayName="unit/regression/github_648_par_decl.mzn")]
	public async Task test_solve_unit_regression_github_648_par_decl() {
		var solver = "gecode";
		var path = "unit/regression/github_648_par_decl.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*declared domain of `x' is 1..3, but assigned value is 0.*");
	}

	[Fact(DisplayName="unit/regression/github_656.mzn")]
	public async Task test_solve_unit_regression_github_656() {
		var solver = "gecode";
		var path = "unit/regression/github_656.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*cannot coerce set into 2-dimensional array.*");
	}

	[Fact(DisplayName="unit/regression/github_661_part1.mzn")]
	public async Task test_solve_unit_regression_github_661_part1() {
		var solver = "gecode";
		var path = "unit/regression/github_661_part1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Unsatisfiable);
	}

	[Fact(DisplayName="unit/regression/github_661_part2.mzn")]
	public async Task test_solve_unit_regression_github_661_part2() {
		var solver = "gecode";
		var path = "unit/regression/github_661_part2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_664.mzn")]
	public async Task test_solve_unit_regression_github_664() {
		var solver = "gecode";
		var path = "unit/regression/github_664.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_666.mzn")]
	public async Task test_solve_unit_regression_github_666() {
		var solver = "gecode";
		var path = "unit/regression/github_666.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-G std");
		var solution = await Solve(model, options, SolveStatus.Unsatisfiable);
	}

	[Theory(DisplayName="unit/regression/github_667.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	[InlineData("highs")]
	public async Task test_solve_unit_regression_github_667(string solver) {
		var path = "unit/regression/github_667.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_668.mzn")]
	public async Task test_solve_unit_regression_github_668() {
		var solver = "gecode";
		var path = "unit/regression/github_668.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_669.mzn")]
	public async Task test_solve_unit_regression_github_669() {
		var solver = "gecode";
		var path = "unit/regression/github_669.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_670.mzn")]
	public async Task test_solve_unit_regression_github_670() {
		var solver = "gecode";
		var path = "unit/regression/github_670.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_671.mzn")]
	public async Task test_solve_unit_regression_github_671() {
		var solver = "gecode";
		var path = "unit/regression/github_671.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_673.mzn")]
	public async Task test_solve_unit_regression_github_673() {
		var solver = "gecode";
		var path = "unit/regression/github_673.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/github_674.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	[InlineData("highs")]
	public async Task test_solve_unit_regression_github_674(string solver) {
		var path = "unit/regression/github_674.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_675a.mzn")]
	public async Task test_solve_unit_regression_github_675a() {
		var solver = "gecode";
		var path = "unit/regression/github_675a.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_675b.mzn")]
	public async Task test_solve_unit_regression_github_675b() {
		var solver = "gecode";
		var path = "unit/regression/github_675b.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--keep-paths");
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_680.mzn")]
	public async Task test_solve_unit_regression_github_680() {
		var solver = "gecode";
		var path = "unit/regression/github_680.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/regression/github_681.mzn")]
	public async Task test_solve_unit_regression_github_681() {
		var solver = "gecode";
		var path = "unit/regression/github_681.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_683.mzn")]
	public async Task test_solve_unit_regression_github_683() {
		var solver = "gecode";
		var path = "unit/regression/github_683.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_685.mzn")]
	public async Task test_solve_unit_regression_github_685() {
		var solver = "gecode";
		var path = "unit/regression/github_685.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_687.mzn")]
	public async Task test_solve_unit_regression_github_687() {
		var solver = "gecode";
		var path = "unit/regression/github_687.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_691.mzn")]
	public async Task test_solve_unit_regression_github_691() {
		var solver = "gecode";
		var path = "unit/regression/github_691.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_693_part1.mzn")]
	public async Task test_solve_unit_regression_github_693_part1() {
		var solver = "gecode";
		var path = "unit/regression/github_693_part1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_693_part2.mzn")]
	public async Task test_solve_unit_regression_github_693_part2() {
		var solver = "gecode";
		var path = "unit/regression/github_693_part2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_695.mzn")]
	public async Task test_solve_unit_regression_github_695() {
		var solver = "gecode";
		var path = "unit/regression/github_695.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_700.mzn")]
	public async Task test_solve_unit_regression_github_700() {
		var solver = "gecode";
		var path = "unit/regression/github_700.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/github_700_bad_sol.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_github_700_bad_sol(string solver) {
		var path = "unit/regression/github_700_bad_sol.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_716.mzn")]
	public async Task test_solve_unit_regression_github_716() {
		var solver = "gecode";
		var path = "unit/regression/github_716.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_725.mzn")]
	public async Task test_solve_unit_regression_github_725() {
		var solver = "gecode";
		var path = "unit/regression/github_725.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		model.HasErrors.Should().BeTrue();
	}

	[Fact(DisplayName="unit/regression/github_726.mzn")]
	public async Task test_solve_unit_regression_github_726() {
		var solver = "gecode";
		var path = "unit/regression/github_726.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_728.mzn")]
	public async Task test_solve_unit_regression_github_728() {
		var solver = "gecode";
		var path = "unit/regression/github_728.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_730.mzn")]
	public async Task test_solve_unit_regression_github_730() {
		var solver = "gecode";
		var path = "unit/regression/github_730.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		model.HasErrors.Should().BeTrue();
	}

	[Fact(DisplayName="unit/regression/github_732.mzn")]
	public async Task test_solve_unit_regression_github_732() {
		var solver = "gecode";
		var path = "unit/regression/github_732.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_747.mzn")]
	public async Task test_solve_unit_regression_github_747() {
		var solver = "gecode";
		var path = "unit/regression/github_747.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_748.mzn")]
	public async Task test_solve_unit_regression_github_748() {
		var solver = "gecode";
		var path = "unit/regression/github_748.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_748.mzn")]
	public async Task test_solve_unit_regression_github_748_case_2() {
		var solver = "gecode";
		var path = "unit/regression/github_748.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-O0");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_749.mzn")]
	public async Task test_solve_unit_regression_github_749() {
		var solver = "gecode";
		var path = "unit/regression/github_749.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_752.mzn")]
	public async Task test_solve_unit_regression_github_752() {
		var solver = "gecode";
		var path = "unit/regression/github_752.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_754.mzn")]
	public async Task test_solve_unit_regression_github_754() {
		var solver = "gecode";
		var path = "unit/regression/github_754.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_758.mzn")]
	public async Task test_solve_unit_regression_github_758() {
		var solver = "gecode";
		var path = "unit/regression/github_758.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_758.mzn")]
	public async Task test_solve_unit_regression_github_758_case_2() {
		var solver = "gecode";
		var path = "unit/regression/github_758.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-O0");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_760.mzn")]
	public async Task test_solve_unit_regression_github_760() {
		var solver = "gecode";
		var path = "unit/regression/github_760.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_761.mzn")]
	public async Task test_solve_unit_regression_github_761() {
		var solver = "gecode";
		var path = "unit/regression/github_761.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_762.mzn")]
	public async Task test_solve_unit_regression_github_762() {
		var solver = "chuffed";
		var path = "unit/regression/github_762.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_765.mzn")]
	public async Task test_solve_unit_regression_github_765() {
		var solver = "gecode";
		var path = "unit/regression/github_765.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Unsatisfiable);
	}

	[Fact(DisplayName="unit/regression/github_766.mzn")]
	public async Task test_solve_unit_regression_github_766() {
		var solver = "gecode";
		var path = "unit/regression/github_766.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_768a.mzn")]
	public async Task test_solve_unit_regression_github_768a() {
		var solver = "gecode";
		var path = "unit/regression/github_768a.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/regression/github_768b.mzn")]
	public async Task test_solve_unit_regression_github_768b() {
		var solver = "gecode";
		var path = "unit/regression/github_768b.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/regression/github_771.mzn")]
	public async Task test_solve_unit_regression_github_771() {
		var solver = "gecode";
		var path = "unit/regression/github_771.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_773.mzn")]
	public async Task test_solve_unit_regression_github_773() {
		var solver = "gecode";
		var path = "unit/regression/github_773.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/regression/github_776.mzn")]
	public async Task test_solve_unit_regression_github_776() {
		var solver = "gecode";
		var path = "unit/regression/github_776.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/regression/github_776.dzn\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/github_778.mzn")]
	public async Task test_solve_unit_regression_github_778() {
		var solver = "gecode";
		var path = "unit/regression/github_778.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_779.mzn")]
	public async Task test_solve_unit_regression_github_779() {
		var solver = "gecode";
		var path = "unit/regression/github_779.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/regression/github_783.mzn")]
	public async Task test_solve_unit_regression_github_783() {
		var solver = "gecode";
		var path = "unit/regression/github_783.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-O2");
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/github_785.mzn")]
	public async Task test_solve_unit_regression_github_785() {
		var solver = "gecode";
		var path = "unit/regression/github_785.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-G std");
		var solution = await Solve(model, options, SolveStatus.Unsatisfiable);
	}

	[Fact(DisplayName="unit/regression/if_then_else_absent.mzn")]
	public async Task test_solve_unit_regression_if_then_else_absent() {
		var solver = "gecode";
		var path = "unit/regression/if_then_else_absent.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/in_array_eval_error.mzn")]
	public async Task test_solve_unit_regression_in_array_eval_error() {
		var solver = "gecode";
		var path = "unit/regression/in_array_eval_error.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/let_domain_from_generator.mzn")]
	public async Task test_solve_unit_regression_let_domain_from_generator() {
		var solver = "gecode";
		var path = "unit/regression/let_domain_from_generator.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/makepar_output.mzn")]
	public async Task test_solve_unit_regression_makepar_output() {
		var solver = "gecode";
		var path = "unit/regression/makepar_output.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/multi_goal_hierarchy_error.mzn")]
	public async Task test_solve_unit_regression_multi_goal_hierarchy_error() {
		var solver = "coin-bc";
		var path = "unit/regression/multi_goal_hierarchy_error.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/non-set-array-ti-location.mzn")]
	public async Task test_solve_unit_regression_non_set_array_ti_location() {
		var solver = "gecode";
		var path = "unit/regression/non-set-array-ti-location.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/regression/non_pos_pow.mzn")]
	public async Task test_solve_unit_regression_non_pos_pow() {
		var solver = "gecode";
		var path = "unit/regression/non_pos_pow.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/nosets_set_search.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_nosets_set_search(string solver) {
		var path = "unit/regression/nosets_set_search.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/opt_minmax.mzn")]
	public async Task test_solve_unit_regression_opt_minmax() {
		var solver = "gecode";
		var path = "unit/regression/opt_minmax.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/opt_noncontiguous_domain.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_opt_noncontiguous_domain(string solver) {
		var path = "unit/regression/opt_noncontiguous_domain.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/output_2d_array_enum.mzn")]
	public async Task test_solve_unit_regression_output_2d_array_enum() {
		var solver = "gecode";
		var path = "unit/regression/output_2d_array_enum.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/output_fn_toplevel_var.mzn")]
	public async Task test_solve_unit_regression_output_fn_toplevel_var() {
		var solver = "gecode";
		var path = "unit/regression/output_fn_toplevel_var.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/output_only_fn.mzn")]
	public async Task test_solve_unit_regression_output_only_fn() {
		var solver = "gecode";
		var path = "unit/regression/output_only_fn.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/regression/output_only_no_rhs.mzn")]
	public async Task test_solve_unit_regression_output_only_no_rhs() {
		var solver = "gecode";
		var path = "unit/regression/output_only_no_rhs.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/regression/parser_location.mzn")]
	public async Task test_solve_unit_regression_parser_location() {
		var solver = "gecode";
		var path = "unit/regression/parser_location.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/regression/parse_assignments.mzn")]
	public async Task test_solve_unit_regression_parse_assignments() {
		var solver = "gecode";
		var path = "unit/regression/parse_assignments.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("--data \"unit/regression/parse_assignments.mzc.mzn\"");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/par_opt_dom.mzn")]
	public async Task test_solve_unit_regression_par_opt_dom() {
		var solver = "gecode";
		var path = "unit/regression/par_opt_dom.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/polymorphic_var_and_par.mzn")]
	public async Task test_solve_unit_regression_polymorphic_var_and_par() {
		var solver = "gecode";
		var path = "unit/regression/polymorphic_var_and_par.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/pow_undefined.mzn")]
	public async Task test_solve_unit_regression_pow_undefined() {
		var solver = "gecode";
		var path = "unit/regression/pow_undefined.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/regression/pred_param_r7550.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_pred_param_r7550(string solver) {
		var path = "unit/regression/pred_param_r7550.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/slice_enum_indexset.mzn")]
	public async Task test_solve_unit_regression_slice_enum_indexset() {
		var solver = "gecode";
		var path = "unit/regression/slice_enum_indexset.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/subsets_100.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_subsets_100(string solver) {
		var path = "unit/regression/subsets_100.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/test_annotation_on_exists.mzn")]
	public async Task test_solve_unit_regression_test_annotation_on_exists() {
		var solver = "gecode";
		var path = "unit/regression/test_annotation_on_exists.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/regression/test_bug359.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_test_bug359(string solver) {
		var path = "unit/regression/test_bug359.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/test_bug54.mzn")]
	public async Task test_solve_unit_regression_test_bug54() {
		var solver = "gecode";
		var path = "unit/regression/test_bug54.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/test_bug54.mzn")]
	public async Task test_solve_unit_regression_test_bug54_case_2() {
		var solver = "chuffed";
		var path = "unit/regression/test_bug54.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/test_bug72.mzn")]
	public async Task test_solve_unit_regression_test_bug72() {
		var solver = "gecode";
		var path = "unit/regression/test_bug72.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/test_bug72.mzn")]
	public async Task test_solve_unit_regression_test_bug72_case_2() {
		var solver = "chuffed";
		var path = "unit/regression/test_bug72.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/test_bug_476.mzn")]
	public async Task test_solve_unit_regression_test_bug_476() {
		var solver = "gecode";
		var path = "unit/regression/test_bug_476.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/test_bug_483.mzn")]
	public async Task test_solve_unit_regression_test_bug_483() {
		var solver = "gecode";
		var path = "unit/regression/test_bug_483.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
	}

	[Fact(DisplayName="unit/regression/test_bug_493.mzn")]
	public async Task test_solve_unit_regression_test_bug_493() {
		var solver = "gecode";
		var path = "unit/regression/test_bug_493.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/test_bug_494.mzn")]
	public async Task test_solve_unit_regression_test_bug_494() {
		var solver = "gecode";
		var path = "unit/regression/test_bug_494.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/test_bug_520.mzn")]
	public async Task test_solve_unit_regression_test_bug_520() {
		var solver = "gecode";
		var path = "unit/regression/test_bug_520.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/test_bug_521.mzn")]
	public async Task test_solve_unit_regression_test_bug_521() {
		var solver = "gecode";
		var path = "unit/regression/test_bug_521.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/test_bug_527.mzn")]
	public async Task test_solve_unit_regression_test_bug_527() {
		var solver = "gecode";
		var path = "unit/regression/test_bug_527.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/test_bug_529.mzn")]
	public async Task test_solve_unit_regression_test_bug_529() {
		var solver = "gecode";
		var path = "unit/regression/test_bug_529.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/test_bug_588.mzn")]
	public async Task test_solve_unit_regression_test_bug_588() {
		var solver = "gecode";
		var path = "unit/regression/test_bug_588.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/test_bug_637.mzn")]
	public async Task test_solve_unit_regression_test_bug_637() {
		var solver = "gecode";
		var path = "unit/regression/test_bug_637.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/regression/test_bug_array_sum_bounds.mzn")]
	public async Task test_solve_unit_regression_test_bug_array_sum_bounds() {
		var solver = "gecode";
		var path = "unit/regression/test_bug_array_sum_bounds.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/test_bug_ite_array_eq.mzn")]
	public async Task test_solve_unit_regression_test_bug_ite_array_eq() {
		var solver = "gecode";
		var path = "unit/regression/test_bug_ite_array_eq.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/test_bug_pred_arg.mzn")]
	public async Task test_solve_unit_regression_test_bug_pred_arg() {
		var solver = "gecode";
		var path = "unit/regression/test_bug_pred_arg.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/regression/test_parout.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_test_parout(string solver) {
		var path = "unit/regression/test_parout.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/test_parout.mzn")]
	public async Task test_solve_unit_regression_test_parout_case_2() {
		var solver = "coin-bc";
		var path = "unit/regression/test_parout.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/regression/ti_error_location.mzn")]
	public async Task test_solve_unit_regression_ti_error_location() {
		var solver = "gecode";
		var path = "unit/regression/ti_error_location.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex("^(?!unknown file:0.0).*$");
	}

	[Fact(DisplayName="unit/regression/ts_bug.mzn")]
	public async Task test_solve_unit_regression_ts_bug() {
		var solver = "gecode";
		var path = "unit/regression/ts_bug.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/regression/var_bool_comp.mzn")]
	public async Task test_solve_unit_regression_var_bool_comp() {
		var solver = "gecode";
		var path = "unit/regression/var_bool_comp.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/regression/var_opt_unconstrained.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_regression_var_opt_unconstrained(string solver) {
		var path = "unit/regression/var_opt_unconstrained.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/regression/var_self_assign_bug.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	[InlineData("coin-bc")]
	public async Task test_solve_unit_regression_var_self_assign_bug(string solver) {
		var path = "unit/regression/var_self_assign_bug.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/search/int_choice_1.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_search_int_choice_1(string solver) {
		var path = "unit/search/int_choice_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/search/int_choice_2.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_search_int_choice_2(string solver) {
		var path = "unit/search/int_choice_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/search/int_choice_6.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_search_int_choice_6(string solver) {
		var path = "unit/search/int_choice_6.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/search/int_var_select_1.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_search_int_var_select_1(string solver) {
		var path = "unit/search/int_var_select_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/search/int_var_select_2.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_search_int_var_select_2(string solver) {
		var path = "unit/search/int_var_select_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/search/int_var_select_3.mzn")]
	public async Task test_solve_unit_search_int_var_select_3() {
		var solver = "chuffed";
		var path = "unit/search/int_var_select_3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/search/int_var_select_4.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_search_int_var_select_4(string solver) {
		var path = "unit/search/int_var_select_4.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/search/int_var_select_6.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_search_int_var_select_6(string solver) {
		var path = "unit/search/int_var_select_6.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/search/test-ff1.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_search_test_ff1(string solver) {
		var path = "unit/search/test-ff1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/search/test-ff2.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_search_test_ff2(string solver) {
		var path = "unit/search/test-ff2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/search/test-ff3.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_search_test_ff3(string solver) {
		var path = "unit/search/test-ff3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/search/test-large1.mzn")]
	public async Task test_solve_unit_search_test_large1() {
		var solver = "gecode";
		var path = "unit/search/test-large1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/search/test-large1.mzn")]
	public async Task test_solve_unit_search_test_large1_case_2() {
		var solver = "chuffed";
		var path = "unit/search/test-large1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/search/test-med1.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_search_test_med1(string solver) {
		var path = "unit/search/test-med1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/search/test-small1.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_search_test_small1(string solver) {
		var path = "unit/search/test-small1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/alias.mzn")]
	public async Task test_solve_unit_types_alias() {
		var solver = "gecode";
		var path = "unit/types/alias.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/alias_call.mzn")]
	public async Task test_solve_unit_types_alias_call() {
		var solver = "gecode";
		var path = "unit/types/alias_call.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/alias_extern_dom.mzn")]
	public async Task test_solve_unit_types_alias_extern_dom() {
		var solver = "gecode";
		var path = "unit/types/alias_extern_dom.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/types/alias_set_of_array.mzn")]
	public async Task test_solve_unit_types_alias_set_of_array() {
		var solver = "gecode";
		var path = "unit/types/alias_set_of_array.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/array_var_opt_set_comprehension.mzn")]
	public async Task test_solve_unit_types_array_var_opt_set_comprehension() {
		var solver = "gecode";
		var path = "unit/types/array_var_opt_set_comprehension.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/comprehension_of_absent_any_1.mzn")]
	public async Task test_solve_unit_types_comprehension_of_absent_any_1() {
		var solver = "gecode";
		var path = "unit/types/comprehension_of_absent_any_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/comprehension_type.mzn")]
	public async Task test_solve_unit_types_comprehension_type() {
		var solver = "gecode";
		var path = "unit/types/comprehension_type.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/cv_comprehension.mzn")]
	public async Task test_solve_unit_types_cv_comprehension() {
		var solver = "gecode";
		var path = "unit/types/cv_comprehension.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/enum_decl.mzn")]
	public async Task test_solve_unit_types_enum_decl() {
		var solver = "gecode";
		var path = "unit/types/enum_decl.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/types/enum_refl.mzn")]
	public async Task test_solve_unit_types_enum_refl() {
		var solver = "gecode";
		var path = "unit/types/enum_refl.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/github_647.mzn")]
	public async Task test_solve_unit_types_github_647() {
		var solver = "gecode";
		var path = "unit/types/github_647.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/nested_type_inst_id.mzn")]
	public async Task test_solve_unit_types_nested_type_inst_id() {
		var solver = "gecode";
		var path = "unit/types/nested_type_inst_id.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*type-inst variable $X used in both array and non-array position.*");
	}

	[Fact(DisplayName="unit/types/nonbool_constraint.mzn")]
	public async Task test_solve_unit_types_nonbool_constraint() {
		var solver = "gecode";
		var path = "unit/types/nonbool_constraint.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/nonbool_constraint_let.mzn")]
	public async Task test_solve_unit_types_nonbool_constraint_let() {
		var solver = "gecode";
		var path = "unit/types/nonbool_constraint_let.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/non_contig_enum.mzn")]
	public async Task test_solve_unit_types_non_contig_enum() {
		var solver = "gecode";
		var path = "unit/types/non_contig_enum.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/overload_inst_tuple_return.mzn")]
	public async Task test_solve_unit_types_overload_inst_tuple_return() {
		var solver = "gecode";
		var path = "unit/types/overload_inst_tuple_return.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/types/par_struct_tiid.mzn")]
	public async Task test_solve_unit_types_par_struct_tiid() {
		var solver = "gecode";
		var path = "unit/types/par_struct_tiid.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/types/polymorphic_overloading.mzn")]
	public async Task test_solve_unit_types_polymorphic_overloading() {
		var solver = "gecode";
		var path = "unit/types/polymorphic_overloading.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/record_access_error.mzn")]
	public async Task test_solve_unit_types_record_access_error() {
		var solver = "gecode";
		var path = "unit/types/record_access_error.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/record_access_success.mzn")]
	public async Task test_solve_unit_types_record_access_success() {
		var solver = "gecode";
		var path = "unit/types/record_access_success.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/record_array_access_error.mzn")]
	public async Task test_solve_unit_types_record_array_access_error() {
		var solver = "gecode";
		var path = "unit/types/record_array_access_error.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/record_binop_par.mzn")]
	public async Task test_solve_unit_types_record_binop_par() {
		var solver = "gecode";
		var path = "unit/types/record_binop_par.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/record_binop_var.mzn")]
	public async Task test_solve_unit_types_record_binop_var() {
		var solver = "gecode";
		var path = "unit/types/record_binop_var.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/record_comprehensions.mzn")]
	public async Task test_solve_unit_types_record_comprehensions() {
		var solver = "gecode";
		var path = "unit/types/record_comprehensions.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/record_decl_error.mzn")]
	public async Task test_solve_unit_types_record_decl_error() {
		var solver = "gecode";
		var path = "unit/types/record_decl_error.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/record_ite_error.mzn")]
	public async Task test_solve_unit_types_record_ite_error() {
		var solver = "gecode";
		var path = "unit/types/record_ite_error.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/record_lit_dup.mzn")]
	public async Task test_solve_unit_types_record_lit_dup() {
		var solver = "gecode";
		var path = "unit/types/record_lit_dup.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/record_nested.mzn")]
	public async Task test_solve_unit_types_record_nested() {
		var solver = "gecode";
		var path = "unit/types/record_nested.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/types/record_output.mzn")]
	public async Task test_solve_unit_types_record_output() {
		var solver = "gecode";
		var path = "unit/types/record_output.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/record_subtyping.mzn")]
	public async Task test_solve_unit_types_record_subtyping() {
		var solver = "gecode";
		var path = "unit/types/record_subtyping.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/record_var_element.mzn")]
	public async Task test_solve_unit_types_record_var_element() {
		var solver = "gecode";
		var path = "unit/types/record_var_element.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/record_var_ite.mzn")]
	public async Task test_solve_unit_types_record_var_ite() {
		var solver = "gecode";
		var path = "unit/types/record_var_ite.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/specialise_large_struct.mzn")]
	public async Task test_solve_unit_types_specialise_large_struct() {
		var solver = "gecode";
		var path = "unit/types/specialise_large_struct.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/struct_array_coercion.mzn")]
	public async Task test_solve_unit_types_struct_array_coercion() {
		var solver = "gecode";
		var path = "unit/types/struct_array_coercion.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/struct_bind_1.mzn")]
	public async Task test_solve_unit_types_struct_bind_1() {
		var solver = "gecode";
		var path = "unit/types/struct_bind_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/types/struct_bind_2.mzn")]
	public async Task test_solve_unit_types_struct_bind_2() {
		var solver = "gecode";
		var path = "unit/types/struct_bind_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/types/struct_domain_1.mzn")]
	public async Task test_solve_unit_types_struct_domain_1() {
		var solver = "gecode";
		var path = "unit/types/struct_domain_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/struct_domain_2.mzn")]
	public async Task test_solve_unit_types_struct_domain_2() {
		var solver = "gecode";
		var path = "unit/types/struct_domain_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/struct_domain_3.mzn")]
	public async Task test_solve_unit_types_struct_domain_3() {
		var solver = "gecode";
		var path = "unit/types/struct_domain_3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/struct_domain_4.mzn")]
	public async Task test_solve_unit_types_struct_domain_4() {
		var solver = "gecode";
		var path = "unit/types/struct_domain_4.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/struct_domain_5.mzn")]
	public async Task test_solve_unit_types_struct_domain_5() {
		var solver = "gecode";
		var path = "unit/types/struct_domain_5.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Unsatisfiable);
	}

	[Fact(DisplayName="unit/types/struct_domain_6.mzn")]
	public async Task test_solve_unit_types_struct_domain_6() {
		var solver = "gecode";
		var path = "unit/types/struct_domain_6.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Unsatisfiable);
	}

	[Fact(DisplayName="unit/types/struct_index_sets_1.mzn")]
	public async Task test_solve_unit_types_struct_index_sets_1() {
		var solver = "gecode";
		var path = "unit/types/struct_index_sets_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".* Declared index set of `x.1' is [1..1], but is assigned to array with index set [2..2].*");
	}

	[Fact(DisplayName="unit/types/struct_index_sets_2.mzn")]
	public async Task test_solve_unit_types_struct_index_sets_2() {
		var solver = "gecode";
		var path = "unit/types/struct_index_sets_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".* Declared index set of `x.1' is [1..1], but is assigned to array with index set [2..2].*");
	}

	[Fact(DisplayName="unit/types/struct_par_function_version.mzn")]
	public async Task test_solve_unit_types_struct_par_function_version() {
		var solver = "gecode";
		var path = "unit/types/struct_par_function_version.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/struct_return_ti_1.mzn")]
	public async Task test_solve_unit_types_struct_return_ti_1() {
		var solver = "gecode";
		var path = "unit/types/struct_return_ti_1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/struct_return_ti_2.mzn")]
	public async Task test_solve_unit_types_struct_return_ti_2() {
		var solver = "gecode";
		var path = "unit/types/struct_return_ti_2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/struct_return_ti_3.mzn")]
	public async Task test_solve_unit_types_struct_return_ti_3() {
		var solver = "gecode";
		var path = "unit/types/struct_return_ti_3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
		solution.Text.Should().MatchRegex(".*function result violates function type-inst.*");
	}

	[Fact(DisplayName="unit/types/struct_return_ti_4.mzn")]
	public async Task test_solve_unit_types_struct_return_ti_4() {
		var solver = "gecode";
		var path = "unit/types/struct_return_ti_4.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Unsatisfiable);
	}

	[Fact(DisplayName="unit/types/struct_specialise.mzn")]
	public async Task test_solve_unit_types_struct_specialise() {
		var solver = "gecode";
		var path = "unit/types/struct_specialise.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/struct_specialise_return.mzn")]
	public async Task test_solve_unit_types_struct_specialise_return() {
		var solver = "gecode";
		var path = "unit/types/struct_specialise_return.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/test_any_enum_typeinstid.mzn")]
	public async Task test_solve_unit_types_test_any_enum_typeinstid() {
		var solver = "gecode";
		var path = "unit/types/test_any_enum_typeinstid.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/types/tuple_access_error1.mzn")]
	public async Task test_solve_unit_types_tuple_access_error1() {
		var solver = "gecode";
		var path = "unit/types/tuple_access_error1.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/tuple_access_error2.mzn")]
	public async Task test_solve_unit_types_tuple_access_error2() {
		var solver = "gecode";
		var path = "unit/types/tuple_access_error2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/tuple_access_success.mzn")]
	public async Task test_solve_unit_types_tuple_access_success() {
		var solver = "gecode";
		var path = "unit/types/tuple_access_success.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/tuple_array_access_error.mzn")]
	public async Task test_solve_unit_types_tuple_array_access_error() {
		var solver = "gecode";
		var path = "unit/types/tuple_array_access_error.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/tuple_binop_par.mzn")]
	public async Task test_solve_unit_types_tuple_binop_par() {
		var solver = "gecode";
		var path = "unit/types/tuple_binop_par.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/tuple_binop_var.mzn")]
	public async Task test_solve_unit_types_tuple_binop_var() {
		var solver = "gecode";
		var path = "unit/types/tuple_binop_var.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/tuple_comprehensions.mzn")]
	public async Task test_solve_unit_types_tuple_comprehensions() {
		var solver = "gecode";
		var path = "unit/types/tuple_comprehensions.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/tuple_int_set_of_int_specialisation.mzn")]
	public async Task test_solve_unit_types_tuple_int_set_of_int_specialisation() {
		var solver = "gecode";
		var path = "unit/types/tuple_int_set_of_int_specialisation.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/tuple_ite_error.mzn")]
	public async Task test_solve_unit_types_tuple_ite_error() {
		var solver = "gecode";
		var path = "unit/types/tuple_ite_error.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/tuple_lit.mzn")]
	public async Task test_solve_unit_types_tuple_lit() {
		var solver = "gecode";
		var path = "unit/types/tuple_lit.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/tuple_mkpar.mzn")]
	public async Task test_solve_unit_types_tuple_mkpar() {
		var solver = "gecode";
		var path = "unit/types/tuple_mkpar.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/tuple_output.mzn")]
	public async Task test_solve_unit_types_tuple_output() {
		var solver = "gecode";
		var path = "unit/types/tuple_output.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/tuple_subtyping.mzn")]
	public async Task test_solve_unit_types_tuple_subtyping() {
		var solver = "gecode";
		var path = "unit/types/tuple_subtyping.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/tuple_var_element.mzn")]
	public async Task test_solve_unit_types_tuple_var_element() {
		var solver = "gecode";
		var path = "unit/types/tuple_var_element.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/tuple_var_ite.mzn")]
	public async Task test_solve_unit_types_tuple_var_ite() {
		var solver = "gecode";
		var path = "unit/types/tuple_var_ite.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/types/var_ann_a.mzn")]
	public async Task test_solve_unit_types_var_ann_a() {
		var solver = "gecode";
		var path = "unit/types/var_ann_a.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/var_ann_b.mzn")]
	public async Task test_solve_unit_types_var_ann_b() {
		var solver = "gecode";
		var path = "unit/types/var_ann_b.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/var_ann_comprehension.mzn")]
	public async Task test_solve_unit_types_var_ann_comprehension() {
		var solver = "gecode";
		var path = "unit/types/var_ann_comprehension.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/var_opt_set_if_then_else.mzn")]
	public async Task test_solve_unit_types_var_opt_set_if_then_else() {
		var solver = "gecode";
		var path = "unit/types/var_opt_set_if_then_else.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/var_set_bool.mzn")]
	public async Task test_solve_unit_types_var_set_bool() {
		var solver = "gecode";
		var path = "unit/types/var_set_bool.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/var_set_float.mzn")]
	public async Task test_solve_unit_types_var_set_float() {
		var solver = "gecode";
		var path = "unit/types/var_set_float.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/var_set_float_comprehension.mzn")]
	public async Task test_solve_unit_types_var_set_float_comprehension() {
		var solver = "gecode";
		var path = "unit/types/var_set_float_comprehension.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/var_string_a.mzn")]
	public async Task test_solve_unit_types_var_string_a() {
		var solver = "gecode";
		var path = "unit/types/var_string_a.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/var_string_b.mzn")]
	public async Task test_solve_unit_types_var_string_b() {
		var solver = "gecode";
		var path = "unit/types/var_string_b.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Fact(DisplayName="unit/types/var_string_comprehension.mzn")]
	public async Task test_solve_unit_types_var_string_comprehension() {
		var solver = "gecode";
		var path = "unit/types/var_string_comprehension.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Error);
	}

	[Theory(DisplayName="unit/globals/alldifferent_except_0/test_alldiff_except0b.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_alldifferent_except_0_test_alldiff_except0b(string solver) {
		var path = "unit/globals/alldifferent_except_0/test_alldiff_except0b.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/arg_max/globals_arg_max.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_arg_max_globals_arg_max(string solver) {
		var path = "unit/globals/arg_max/globals_arg_max.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/arg_max/globals_arg_max_opt.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_arg_max_globals_arg_max_opt(string solver) {
		var path = "unit/globals/arg_max/globals_arg_max_opt.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/arg_max/globals_arg_max_opt_weak.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_arg_max_globals_arg_max_opt_weak(string solver) {
		var path = "unit/globals/arg_max/globals_arg_max_opt_weak.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/arg_min/globals_arg_max_opt.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_arg_min_globals_arg_max_opt(string solver) {
		var path = "unit/globals/arg_min/globals_arg_max_opt.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/arg_min/globals_arg_min.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_arg_min_globals_arg_min(string solver) {
		var path = "unit/globals/arg_min/globals_arg_min.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/arg_min/globals_arg_min_opt_weak.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_arg_min_globals_arg_min_opt_weak(string solver) {
		var path = "unit/globals/arg_min/globals_arg_min_opt_weak.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/arg_val/arg_val_enum.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_arg_val_arg_val_enum(string solver) {
		var path = "unit/globals/arg_val/arg_val_enum.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/bin_packing/globals_bin_packing.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_bin_packing_globals_bin_packing(string solver) {
		var path = "unit/globals/bin_packing/globals_bin_packing.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/bin_packing_capa/globals_bin_packing_capa.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_bin_packing_capa_globals_bin_packing_capa(string solver) {
		var path = "unit/globals/bin_packing_capa/globals_bin_packing_capa.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/circuit/test_circuit.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_circuit_test_circuit(string solver) {
		var path = "unit/globals/circuit/test_circuit.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/globals/cumulative/github_589.mzn")]
	public async Task test_solve_unit_globals_cumulative_github_589() {
		var solver = "gecode";
		var path = "unit/globals/cumulative/github_589.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-G std");
		var solution = await Solve(model,options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/globals/cumulatives/globals_cumulatives.mzn")]
	public async Task test_solve_unit_globals_cumulatives_globals_cumulatives() {
		var solver = "gecode";
		var path = "unit/globals/cumulatives/globals_cumulatives.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/globals/cumulatives/globals_cumulatives.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_cumulatives_globals_cumulatives_case_2(string solver) {
		var path = "unit/globals/cumulatives/globals_cumulatives.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-G std");
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/globals/global_cardinality/globals_global_cardinality_low_up_set.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_global_cardinality_globals_global_cardinality_low_up_set(string solver) {
		var path = "unit/globals/global_cardinality/globals_global_cardinality_low_up_set.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/global_cardinality/globals_global_cardinality_opt.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_global_cardinality_globals_global_cardinality_opt(string solver) {
		var path = "unit/globals/global_cardinality/globals_global_cardinality_opt.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/global_cardinality/globals_global_cardinality_set.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_global_cardinality_globals_global_cardinality_set(string solver) {
		var path = "unit/globals/global_cardinality/globals_global_cardinality_set.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/global_cardinality_closed/globals_global_cardinality_closed_opt.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_global_cardinality_closed_globals_global_cardinality_closed_opt(string solver) {
		var path = "unit/globals/global_cardinality_closed/globals_global_cardinality_closed_opt.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/global_cardinality_closed/globals_global_cardinality_closed_set.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_global_cardinality_closed_globals_global_cardinality_closed_set(string solver) {
		var path = "unit/globals/global_cardinality_closed/globals_global_cardinality_closed_set.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/global_cardinality_closed/globals_global_cardinality_low_up_closed_opt.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_global_cardinality_closed_globals_global_cardinality_low_up_closed_opt(string solver) {
		var path = "unit/globals/global_cardinality_closed/globals_global_cardinality_low_up_closed_opt.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/global_cardinality_closed/globals_global_cardinality_low_up_closed_set.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_global_cardinality_closed_globals_global_cardinality_low_up_closed_set(string solver) {
		var path = "unit/globals/global_cardinality_closed/globals_global_cardinality_low_up_closed_set.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/int_set_channel/test_int_set_channel2.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	[InlineData("coin-bc")]
	public async Task test_solve_unit_globals_int_set_channel_test_int_set_channel2(string solver) {
		var path = "unit/globals/int_set_channel/test_int_set_channel2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Fact(DisplayName="unit/globals/inverse/inverse_opt.mzn")]
	public async Task test_solve_unit_globals_inverse_inverse_opt() {
		var solver = "gecode";
		var path = "unit/globals/inverse/inverse_opt.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		options = options.AddArgs("-G std");
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/lex2/globals_lex2.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_lex2_globals_lex2(string solver) {
		var path = "unit/globals/lex2/globals_lex2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/globals/lex2/globals_lex2.mzn")]
	public async Task test_solve_unit_globals_lex2_globals_lex2_case_2() {
		var solver = "coin-bc";
		var path = "unit/globals/lex2/globals_lex2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/globals/lex_chain/globals_lex_chain__orbitope.mzn")]
	[InlineData("gecode")]
	[InlineData("coin-bc")]
	[InlineData("scip", Skip="Solver not supported")]
	public async Task test_solve_unit_globals_lex_chain_globals_lex_chain__orbitope(string solver) {
		var path = "unit/globals/lex_chain/globals_lex_chain__orbitope.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/globals/lex_greater/globals_lex_greater.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_lex_greater_globals_lex_greater(string solver) {
		var path = "unit/globals/lex_greater/globals_lex_greater.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/lex_greatereq/globals_lex_greatereq.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_lex_greatereq_globals_lex_greatereq(string solver) {
		var path = "unit/globals/lex_greatereq/globals_lex_greatereq.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/lex_less/test_bool_lex_less.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_lex_less_test_bool_lex_less(string solver) {
		var path = "unit/globals/lex_less/test_bool_lex_less.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/lex_lesseq/test_bool_lex_lesseq.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_lex_lesseq_test_bool_lex_lesseq(string solver) {
		var path = "unit/globals/lex_lesseq/test_bool_lex_lesseq.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/nvalue/globals_nvalue.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_nvalue_globals_nvalue(string solver) {
		var path = "unit/globals/nvalue/globals_nvalue.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/globals/nvalue/nvalue_total.mzn")]
	public async Task test_solve_unit_globals_nvalue_nvalue_total() {
		var solver = "gecode";
		var path = "unit/globals/nvalue/nvalue_total.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/globals/range/globals_range.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_range_globals_range(string solver) {
		var path = "unit/globals/range/globals_range.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Fact(DisplayName="unit/globals/regular/globals_regular.mzn")]
	public async Task test_solve_unit_globals_regular_globals_regular() {
		var solver = "gecode";
		var path = "unit/globals/regular/globals_regular.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="unit/globals/regular/globals_regular_regex_3.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_regular_globals_regular_regex_3(string solver) {
		var path = "unit/globals/regular/globals_regular_regex_3.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/regular/globals_regular_regex_5.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_regular_globals_regular_regex_5(string solver) {
		var path = "unit/globals/regular/globals_regular_regex_5.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/roots/test_roots2.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_roots_test_roots2(string solver) {
		var path = "unit/globals/roots/test_roots2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/strict_lex2/globals_strict_lex2.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_strict_lex2_globals_strict_lex2(string solver) {
		var path = "unit/globals/strict_lex2/globals_strict_lex2.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/subcircuit/test_subcircuit.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_subcircuit_test_subcircuit(string solver) {
		var path = "unit/globals/subcircuit/test_subcircuit.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/table/globals_table_opt.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_table_globals_table_opt(string solver) {
		var path = "unit/globals/table/globals_table_opt.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/value_precede/globals_value_precede_int.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_value_precede_globals_value_precede_int(string solver) {
		var path = "unit/globals/value_precede/globals_value_precede_int.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/value_precede/globals_value_precede_int_opt.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_value_precede_globals_value_precede_int_opt(string solver) {
		var path = "unit/globals/value_precede/globals_value_precede_int_opt.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/value_precede/globals_value_precede_set.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_value_precede_globals_value_precede_set(string solver) {
		var path = "unit/globals/value_precede/globals_value_precede_set.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/value_precede_chain/globals_value_precede_chain_int.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_value_precede_chain_globals_value_precede_chain_int(string solver) {
		var path = "unit/globals/value_precede_chain/globals_value_precede_chain_int.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/value_precede_chain/globals_value_precede_chain_int_opt.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_value_precede_chain_globals_value_precede_chain_int_opt(string solver) {
		var path = "unit/globals/value_precede_chain/globals_value_precede_chain_int_opt.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/value_precede_chain/globals_value_precede_chain_set.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_value_precede_chain_globals_value_precede_chain_set(string solver) {
		var path = "unit/globals/value_precede_chain/globals_value_precede_chain_set.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="unit/globals/var_sqr_sym/globals_var_sqr_sym.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_unit_globals_var_sqr_sym_globals_var_sqr_sym(string solver) {
		var path = "unit/globals/var_sqr_sym/globals_var_sqr_sym.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied);
	}

	[Theory(DisplayName="examples/battleships_4.mzn")]
	[InlineData("gecode")]
	[InlineData("coin-bc")]
	[InlineData("chuffed")]
	public async Task test_solve_examples_battleships_4(string solver) {
		var path = "examples/battleships_4.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="examples/battleships_7.mzn")]
	[InlineData("gecode")]
	[InlineData("coin-bc")]
	[InlineData("chuffed")]
	public async Task test_solve_examples_battleships_7(string solver) {
		var path = "examples/battleships_7.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="examples/factory_planning_instance.mzn")]
	[InlineData("gecode")]
	[InlineData("coin-bc")]
	[InlineData("chuffed")]
	public async Task test_solve_examples_factory_planning_instance(string solver) {
		var path = "examples/factory_planning_instance.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="examples/knights.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_examples_knights(string solver) {
		var path = "examples/knights.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="examples/magicsq_4.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_examples_magicsq_4(string solver) {
		var path = "examples/magicsq_4.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="examples/magicsq_5.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_examples_magicsq_5(string solver) {
		var path = "examples/magicsq_5.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="examples/oss.mzn")]
	[InlineData("gecode")]
	[InlineData("coin-bc")]
	[InlineData("chuffed")]
	public async Task test_solve_examples_oss(string solver) {
		var path = "examples/oss.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="examples/packing.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_examples_packing(string solver) {
		var path = "examples/packing.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="examples/radiation.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_examples_radiation(string solver) {
		var path = "examples/radiation.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model,options,SolveStatus.Optimal);
	}

	[Theory(DisplayName="examples/template_design.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_examples_template_design(string solver) {
		var path = "examples/template_design.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	[Theory(DisplayName="examples/wolf_goat_cabbage.mzn")]
	[InlineData("gecode")]
	[InlineData("chuffed")]
	public async Task test_solve_examples_wolf_goat_cabbage_case_2(string solver) {
		var path = "examples/wolf_goat_cabbage.mzn";
		var model = Compile(path);
		var options = SolveOptions.Create(solverId:solver);
		var solution = await Solve(model, options, SolveStatus.Satisfied, SolveStatus.Optimal);
	}

	}